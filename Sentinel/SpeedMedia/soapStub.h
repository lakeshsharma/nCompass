/* soapStub.h
   Generated by gSOAP 2.8.40 for cacheservice.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"
#define SOAP_NAMESPACE_OF_ns2	"http://schemas.microsoft.com/2003/10/Serialization/Arrays"
#define SOAP_NAMESPACE_OF_ns3	"http://schemas.datacontract.org/2004/07/Aristocrat.OASIS.Business.SpeedMediaEvents"
#define SOAP_NAMESPACE_OF_ns4	"http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20840
# error "GSOAP VERSION 20840 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* cacheservice.h:656 */
#ifndef SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType
#define SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType (146)
/* ns3:EventData.CustomMessageJustificationType */
enum ns3__EventData_x002eCustomMessageJustificationType {
	ns3__EventData_x002eCustomMessageJustificationType__Left = 0,
	ns3__EventData_x002eCustomMessageJustificationType__Center = 1,
	ns3__EventData_x002eCustomMessageJustificationType__Right = 2
};
#endif

/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (354)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:100 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (357)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (431)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:112 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (460)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:118 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (514)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* cacheservice.h:147 */
class xsd__base64Binary;	/* cacheservice.h:150 */
class xsd__ID_;	/* cacheservice.h:168 */
class xsd__IDREF_;	/* cacheservice.h:178 */
class xsd__QName;	/* cacheservice.h:185 */
class xsd__anyURI_;	/* cacheservice.h:195 */
class xsd__base64Binary_;	/* cacheservice.h:202 */
class xsd__boolean;	/* cacheservice.h:209 */
class xsd__byte_;	/* cacheservice.h:216 */
class xsd__dateTime;	/* cacheservice.h:223 */
class xsd__decimal_;	/* cacheservice.h:233 */
class xsd__double;	/* cacheservice.h:240 */
class xsd__duration_;	/* cacheservice.h:250 */
class xsd__float;	/* cacheservice.h:257 */
class xsd__int;	/* cacheservice.h:264 */
class xsd__long;	/* cacheservice.h:271 */
class xsd__short;	/* cacheservice.h:278 */
class xsd__string;	/* cacheservice.h:285 */
class xsd__unsignedByte_;	/* cacheservice.h:292 */
class xsd__unsignedInt;	/* cacheservice.h:299 */
class xsd__unsignedLong;	/* cacheservice.h:306 */
class xsd__unsignedShort;	/* cacheservice.h:313 */
class ns3__EventData_x002eCustomMessageJustificationType_;	/* cacheservice.h:664 */
class ns4__char__;	/* cacheservice.h:683 */
class ns4__duration__;	/* cacheservice.h:696 */
class ns4__guid__;	/* cacheservice.h:708 */
class _ns1__Checkin;	/* cacheservice.h:327 */
class _ns1__CheckinResponse;	/* cacheservice.h:330 */
class _ns1__GetEventStartNotification;	/* cacheservice.h:333 */
class _ns1__GetEventStartNotificationResponse;	/* cacheservice.h:336 */
class _ns1__GetEventStartNotificationV25;	/* cacheservice.h:339 */
class _ns1__GetEventStartNotificationV25Response;	/* cacheservice.h:342 */
class _ns1__GetCMPStatusNotification;	/* cacheservice.h:345 */
class _ns1__GetCMPStatusNotificationResponse;	/* cacheservice.h:348 */
class _ns1__GetSentinelConfigNotification;	/* cacheservice.h:351 */
class _ns1__GetSentinelConfigNotificationResponse;	/* cacheservice.h:354 */
class _ns1__GetSplashdownTriggeredEventNotificationCustom;	/* cacheservice.h:357 */
class _ns1__GetSplashdownTriggeredEventNotificationCustomResponse;	/* cacheservice.h:360 */
class _ns1__GetSplashdownAwardNotificationCustom;	/* cacheservice.h:363 */
class _ns1__GetSplashdownAwardNotificationCustomResponse;	/* cacheservice.h:366 */
class _ns1__GetSplashdownAwardNotificationCustomWithMediaData;	/* cacheservice.h:369 */
class _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse;	/* cacheservice.h:372 */
class _ns1__GetRicochetTriggeredEventNotificationCustom;	/* cacheservice.h:375 */
class _ns1__GetRicochetTriggeredEventNotificationCustomResponse;	/* cacheservice.h:378 */
class _ns1__GetRicochetAwardNotificationCustom;	/* cacheservice.h:381 */
class _ns1__GetRicochetAwardNotificationCustomResponse;	/* cacheservice.h:384 */
class _ns1__GetRicochetAwardNotificationCustomWithMediaData;	/* cacheservice.h:387 */
class _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse;	/* cacheservice.h:390 */
class _ns1__GetJackpotAnnouncementNotification;	/* cacheservice.h:393 */
class _ns1__GetJackpotAnnouncementNotificationResponse;	/* cacheservice.h:396 */
class _ns1__GetTriggerlessAnnouncementNotification;	/* cacheservice.h:399 */
class _ns1__GetTriggerlessAnnouncementNotificationResponse;	/* cacheservice.h:402 */
class _ns1__GetExternalPaidNotification;	/* cacheservice.h:405 */
class _ns1__GetExternalPaidNotificationResponse;	/* cacheservice.h:408 */
class _ns1__GetTriggerRejectedNotification;	/* cacheservice.h:411 */
class _ns1__GetTriggerRejectedNotificationResponse;	/* cacheservice.h:414 */
class _ns1__GetSpeedMediaVersion;	/* cacheservice.h:417 */
class _ns1__GetSpeedMediaVersionResponse;	/* cacheservice.h:420 */
class _ns1__CardIn;	/* cacheservice.h:423 */
class _ns1__CardInResponse;	/* cacheservice.h:426 */
class _ns1__CardOut;	/* cacheservice.h:429 */
class _ns1__CardOutResponse;	/* cacheservice.h:432 */
class _ns1__GamePlayedAfterCardIn;	/* cacheservice.h:435 */
class _ns1__GamePlayedAfterCardInResponse;	/* cacheservice.h:438 */
class _ns1__RequestNonCardedEvents;	/* cacheservice.h:441 */
class _ns1__RequestNonCardedEventsResponse;	/* cacheservice.h:444 */
class _ns1__GetFlashStartAnnouncement;	/* cacheservice.h:447 */
class _ns1__GetFlashStartAnnouncementResponse;	/* cacheservice.h:450 */
class _ns1__GetFlashUdpCompleteAnnouncement;	/* cacheservice.h:453 */
class _ns1__GetFlashUdpCompleteAnnouncementResponse;	/* cacheservice.h:456 */
class _ns1__GetFileInformation;	/* cacheservice.h:459 */
class _ns1__GetFileInformationResponse;	/* cacheservice.h:462 */
class _ns1__GetConfig;	/* cacheservice.h:465 */
class _ns1__GetConfigResponse;	/* cacheservice.h:468 */
class _ns1__GetConfigEx;	/* cacheservice.h:471 */
class _ns1__GetConfigExResponse;	/* cacheservice.h:474 */
class _ns1__GetEventXMLFile;	/* cacheservice.h:477 */
class _ns1__GetEventXMLFileResponse;	/* cacheservice.h:480 */
class _ns1__InEventTrigger;	/* cacheservice.h:483 */
class _ns1__InEventTriggerResponse;	/* cacheservice.h:486 */
class _ns1__InTriggeredEventTrigger;	/* cacheservice.h:489 */
class _ns1__InTriggeredEventTriggerResponse;	/* cacheservice.h:492 */
class _ns1__ReportEventMeterDeltas;	/* cacheservice.h:495 */
class _ns1__ReportEventMeterDeltasResponse;	/* cacheservice.h:498 */
class _ns1__ReportGameStart;	/* cacheservice.h:501 */
class _ns1__ReportGameStartResponse;	/* cacheservice.h:504 */
class _ns1__AcknowledgeExternalPaid;	/* cacheservice.h:507 */
class _ns1__AcknowledgeExternalPaidResponse;	/* cacheservice.h:510 */
class _ns1__ReportStatus;	/* cacheservice.h:513 */
class _ns1__ReportStatusResponse;	/* cacheservice.h:516 */
class _ns1__ReportSentinelInformation;	/* cacheservice.h:519 */
class _ns1__ReportSentinelInformationResponse;	/* cacheservice.h:522 */
class _ns1__ReportSentinelInformationWithOrientation;	/* cacheservice.h:525 */
class _ns1__ReportSentinelInformationWithOrientationResponse;	/* cacheservice.h:528 */
class _ns1__ReportSentinelInformationEx;	/* cacheservice.h:531 */
class _ns1__ReportSentinelInformationExResponse;	/* cacheservice.h:534 */
class _ns1__ReportSentinelInformation25;	/* cacheservice.h:537 */
class _ns1__ReportSentinelInformation25Response;	/* cacheservice.h:540 */
class _ns1__GetThirdPartyBlob;	/* cacheservice.h:543 */
class _ns1__GetThirdPartyBlobResponse;	/* cacheservice.h:546 */
class _ns1__SendBlobToThirdParty;	/* cacheservice.h:549 */
class _ns1__SendBlobToThirdPartyResponse;	/* cacheservice.h:552 */
class _ns1__GetEventTriggerNotification;	/* cacheservice.h:555 */
class _ns1__GetEventTriggerNotificationResponse;	/* cacheservice.h:558 */
class _ns1__GetCasinoChallengeTriggeredEventNotificationCustom;	/* cacheservice.h:561 */
class _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse;	/* cacheservice.h:564 */
class _ns1__GetCasinoChallangeIncrementNotification;	/* cacheservice.h:567 */
class _ns1__GetCasinoChallangeIncrementNotificationResponse;	/* cacheservice.h:570 */
class _ns1__GetCasinoChallangeEventEndNotificationCustom;	/* cacheservice.h:573 */
class _ns1__GetCasinoChallangeEventEndNotificationCustomResponse;	/* cacheservice.h:576 */
class _ns1__GetCasinoChallengeAwardNotificationCustom;	/* cacheservice.h:579 */
class _ns1__GetCasinoChallengeAwardNotificationCustomResponse;	/* cacheservice.h:582 */
class _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData;	/* cacheservice.h:585 */
class _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse;	/* cacheservice.h:588 */
class _ns1__GetCacheMethodList;	/* cacheservice.h:591 */
class _ns1__GetCacheMethodListResponse;	/* cacheservice.h:594 */
class ns2__ArrayOfbase64Binary;	/* cacheservice.h:597 */
class ns2__ArrayOfint;	/* cacheservice.h:600 */
class ns2__ArrayOflong;	/* cacheservice.h:603 */
class _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring;	/* cacheservice.h:3305 */
class ns2__ArrayOfKeyValueOfstringstring;	/* cacheservice.h:606 */
class ns2__ArrayOfstring;	/* cacheservice.h:609 */
class ns3__CustomMessageScreen;	/* cacheservice.h:612 */
class ns3__ArrayOfCustomMessageLine;	/* cacheservice.h:615 */
class ns3__CustomMessageLine;	/* cacheservice.h:618 */
struct __ns1__Checkin;	/* cacheservice.h:3826 */
struct __ns1__GetEventStartNotification;	/* cacheservice.h:3896 */
struct __ns1__GetEventStartNotificationV25;	/* cacheservice.h:3966 */
struct __ns1__GetCMPStatusNotification;	/* cacheservice.h:4036 */
struct __ns1__GetSentinelConfigNotification;	/* cacheservice.h:4106 */
struct __ns1__GetSplashdownTriggeredEventNotificationCustom;	/* cacheservice.h:4176 */
struct __ns1__GetSplashdownAwardNotificationCustom;	/* cacheservice.h:4246 */
struct __ns1__GetSplashdownAwardNotificationCustomWithMediaData;	/* cacheservice.h:4316 */
struct __ns1__GetRicochetTriggeredEventNotificationCustom;	/* cacheservice.h:4386 */
struct __ns1__GetRicochetAwardNotificationCustom;	/* cacheservice.h:4456 */
struct __ns1__GetRicochetAwardNotificationCustomWithMediaData;	/* cacheservice.h:4526 */
struct __ns1__GetJackpotAnnouncementNotification;	/* cacheservice.h:4596 */
struct __ns1__GetTriggerlessAnnouncementNotification;	/* cacheservice.h:4666 */
struct __ns1__GetExternalPaidNotification;	/* cacheservice.h:4736 */
struct __ns1__GetTriggerRejectedNotification;	/* cacheservice.h:4806 */
struct __ns1__GetSpeedMediaVersion;	/* cacheservice.h:4876 */
struct __ns1__CardIn;	/* cacheservice.h:4946 */
struct __ns1__CardOut;	/* cacheservice.h:5016 */
struct __ns1__GamePlayedAfterCardIn;	/* cacheservice.h:5086 */
struct __ns1__RequestNonCardedEvents;	/* cacheservice.h:5156 */
struct __ns1__GetFlashStartAnnouncement;	/* cacheservice.h:5226 */
struct __ns1__GetFlashUdpCompleteAnnouncement;	/* cacheservice.h:5296 */
struct __ns1__GetFileInformation;	/* cacheservice.h:5366 */
struct __ns1__GetConfig;	/* cacheservice.h:5436 */
struct __ns1__GetConfigEx;	/* cacheservice.h:5506 */
struct __ns1__GetEventXMLFile;	/* cacheservice.h:5576 */
struct __ns1__InEventTrigger;	/* cacheservice.h:5646 */
struct __ns1__InTriggeredEventTrigger;	/* cacheservice.h:5716 */
struct __ns1__ReportEventMeterDeltas;	/* cacheservice.h:5786 */
struct __ns1__ReportGameStart;	/* cacheservice.h:5856 */
struct __ns1__AcknowledgeExternalPaid;	/* cacheservice.h:5926 */
struct __ns1__ReportStatus;	/* cacheservice.h:5996 */
struct __ns1__ReportSentinelInformation;	/* cacheservice.h:6066 */
struct __ns1__ReportSentinelInformationWithOrientation;	/* cacheservice.h:6136 */
struct __ns1__ReportSentinelInformationEx;	/* cacheservice.h:6206 */
struct __ns1__ReportSentinelInformation25;	/* cacheservice.h:6276 */
struct __ns1__GetThirdPartyBlob;	/* cacheservice.h:6346 */
struct __ns1__SendBlobToThirdParty;	/* cacheservice.h:6416 */
struct __ns1__GetEventTriggerNotification;	/* cacheservice.h:6486 */
struct __ns1__GetCasinoChallengeTriggeredEventNotificationCustom;	/* cacheservice.h:6556 */
struct __ns1__GetCasinoChallangeIncrementNotification;	/* cacheservice.h:6626 */
struct __ns1__GetCasinoChallangeEventEndNotificationCustom;	/* cacheservice.h:6696 */
struct __ns1__GetCasinoChallengeAwardNotificationCustom;	/* cacheservice.h:6766 */
struct __ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData;	/* cacheservice.h:6836 */
struct __ns1__GetCacheMethodList;	/* cacheservice.h:6906 */
struct _wsu__Timestamp;	/* wsu.h:76 */
struct wsse__EncodedString;	/* wsse.h:57 */
struct _wsse__UsernameToken;	/* wsse.h:128 */
struct _wsse__BinarySecurityToken;	/* wsse.h:139 */
struct _wsse__Reference;	/* wsse.h:149 */
struct _wsse__Embedded;	/* wsse.h:157 */
struct _wsse__KeyIdentifier;	/* wsse.h:166 */
struct _wsse__SecurityTokenReference;	/* wsse.h:176 */
struct ds__SignatureType;	/* ds.h:46 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:73 */
struct ds__KeyInfoType;	/* ds.h:48 */
struct ds__SignedInfoType;	/* ds.h:46 */
struct ds__CanonicalizationMethodType;	/* ds.h:59 */
struct ds__SignatureMethodType;	/* ds.h:62 */
struct ds__ReferenceType;	/* ds.h:65 */
struct ds__TransformsType;	/* ds.h:68 */
struct ds__DigestMethodType;	/* ds.h:79 */
struct ds__KeyValueType;	/* ds.h:84 */
struct ds__RetrievalMethodType;	/* ds.h:85 */
struct ds__X509DataType;	/* wsse.h:179 */
struct ds__X509IssuerSerialType;	/* ds.h:102 */
struct ds__DSAKeyValueType;	/* ds.h:123 */
struct ds__RSAKeyValueType;	/* ds.h:126 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct __saml1__union_AssertionType;	/* saml1.h:145 */
struct saml1__AssertionType;	/* saml1.h:61 */
struct __saml1__union_ConditionsType;	/* saml1.h:187 */
struct saml1__ConditionsType;	/* saml1.h:63 */
struct saml1__ConditionAbstractType;	/* saml1.h:65 */
struct __saml1__union_AdviceType;	/* saml1.h:227 */
struct saml1__AdviceType;	/* saml1.h:71 */
struct saml1__StatementAbstractType;	/* saml1.h:73 */
struct saml1__SubjectType;	/* saml1.h:77 */
struct saml1__SubjectConfirmationType;	/* saml1.h:81 */
struct saml1__SubjectLocalityType;	/* saml1.h:85 */
struct saml1__AuthorityBindingType;	/* saml1.h:87 */
struct __saml1__union_EvidenceType;	/* saml1.h:344 */
struct saml1__EvidenceType;	/* saml1.h:93 */
struct saml1__AttributeDesignatorType;	/* saml1.h:97 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:67 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:69 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:75 */
struct saml1__NameIdentifierType;	/* saml1.h:79 */
struct saml1__ActionType;	/* saml1.h:91 */
struct saml1__AttributeType;	/* saml1.h:99 */
struct saml1__AuthenticationStatementType;	/* saml1.h:83 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:89 */
struct saml1__AttributeStatementType;	/* saml1.h:95 */
struct saml2__BaseIDAbstractType;	/* saml2.h:61 */
struct saml2__EncryptedElementType;	/* saml2.h:65 */
struct __saml2__union_AssertionType;	/* saml2.h:193 */
struct saml2__AssertionType;	/* saml2.h:67 */
struct saml2__SubjectType;	/* saml2.h:69 */
struct saml2__SubjectConfirmationType;	/* saml2.h:71 */
struct __saml2__union_ConditionsType;	/* saml2.h:284 */
struct saml2__ConditionsType;	/* saml2.h:77 */
struct saml2__ConditionAbstractType;	/* saml2.h:79 */
struct __saml2__union_AdviceType;	/* saml2.h:326 */
struct saml2__AdviceType;	/* saml2.h:87 */
struct saml2__StatementAbstractType;	/* saml2.h:89 */
struct saml2__SubjectLocalityType;	/* saml2.h:93 */
struct saml2__AuthnContextType;	/* saml2.h:95 */
struct __saml2__union_EvidenceType;	/* saml2.h:421 */
struct saml2__EvidenceType;	/* saml2.h:101 */
struct saml2__AttributeType;	/* saml2.h:105 */
struct saml2__NameIDType;	/* saml2.h:63 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:73 */
struct saml2__AudienceRestrictionType;	/* saml2.h:81 */
struct saml2__OneTimeUseType;	/* saml2.h:83 */
struct saml2__ProxyRestrictionType;	/* saml2.h:85 */
struct saml2__AuthnStatementType;	/* saml2.h:91 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:97 */
struct saml2__ActionType;	/* saml2.h:99 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:653 */
struct saml2__AttributeStatementType;	/* saml2.h:103 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:75 */
struct _wsse__Security;	/* wsse.h:193 */
struct _wsse__Password;	/* wsse.h:129 */

/* cacheservice.h:147 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType()
        {
          __item = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:150 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary()
        {
          __ptr = (unsigned char *)0;
          __size = 0;
          id = NULL;
          type = (char *)0;
          options = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:168 */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (16)
/* Type xsd__ID_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:ID': */
class SOAP_CMAC xsd__ID_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:ID' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__ID_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID_, default initialized and not managed by a soap context
        virtual xsd__ID_ *soap_alloc(void) const { return SOAP_NEW(xsd__ID_); }
      public:
        /// Constructor with initializations
        xsd__ID_()
        {
          __item = (char *)0;
        }
        virtual ~xsd__ID_() { }
        /// Friend allocator used by soap_new_xsd__ID_(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:178 */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (18)
/* Type xsd__IDREF_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:IDREF' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__IDREF_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF_, default initialized and not managed by a soap context
        virtual xsd__IDREF_ *soap_alloc(void) const { return SOAP_NEW(xsd__IDREF_); }
      public:
        /// Constructor with initializations
        xsd__IDREF_()
        {
          __item = (char *)0;
        }
        virtual ~xsd__IDREF_() { }
        /// Friend allocator used by soap_new_xsd__IDREF_(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:185 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (19)
/* Type xsd__QName is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:QName': */
class SOAP_CMAC xsd__QName : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:QName' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__QName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName, default initialized and not managed by a soap context
        virtual xsd__QName *soap_alloc(void) const { return SOAP_NEW(xsd__QName); }
      public:
        /// Constructor with initializations
        xsd__QName()
        {
          __item = (char *)0;
        }
        virtual ~xsd__QName() { }
        /// Friend allocator used by soap_new_xsd__QName(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:195 */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (21)
/* Type xsd__anyURI_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyURI' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyURI_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI_, default initialized and not managed by a soap context
        virtual xsd__anyURI_ *soap_alloc(void) const { return SOAP_NEW(xsd__anyURI_); }
      public:
        /// Constructor with initializations
        xsd__anyURI_()
        {
          __item = (char *)0;
        }
        virtual ~xsd__anyURI_() { }
        /// Friend allocator used by soap_new_xsd__anyURI_(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:202 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (22)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_()
        {
        }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:209 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (23)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean()
        {
          __item = (bool)0;
        }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:216 */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (25)
/* Type xsd__byte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:byte': */
class SOAP_CMAC xsd__byte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__byte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte_, default initialized and not managed by a soap context
        virtual xsd__byte_ *soap_alloc(void) const { return SOAP_NEW(xsd__byte_); }
      public:
        /// Constructor with initializations
        xsd__byte_()
        {
          __item = (char)0;
        }
        virtual ~xsd__byte_() { }
        /// Friend allocator used by soap_new_xsd__byte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:223 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (26)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime()
        {
          __item = (time_t)0;
        }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:233 */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (29)
/* Type xsd__decimal_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:decimal' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__decimal_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal_, default initialized and not managed by a soap context
        virtual xsd__decimal_ *soap_alloc(void) const { return SOAP_NEW(xsd__decimal_); }
      public:
        /// Constructor with initializations
        xsd__decimal_()
        {
          __item = (char *)0;
        }
        virtual ~xsd__decimal_() { }
        /// Friend allocator used by soap_new_xsd__decimal_(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:240 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (30)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double()
        {
          __item = (double)0;
        }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:250 */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (33)
/* Type xsd__duration_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:duration': */
class SOAP_CMAC xsd__duration_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:duration' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__duration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration_, default initialized and not managed by a soap context
        virtual xsd__duration_ *soap_alloc(void) const { return SOAP_NEW(xsd__duration_); }
      public:
        /// Constructor with initializations
        xsd__duration_()
        {
          __item = (char *)0;
        }
        virtual ~xsd__duration_() { }
        /// Friend allocator used by soap_new_xsd__duration_(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:257 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (34)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float()
        {
          __item = (float)0;
        }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:264 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (36)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int()
        {
          __item = (int)0;
        }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:271 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (37)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long()
        {
          __item = (LONG64)0;
        }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:278 */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (39)
/* Type xsd__short is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:short': */
class SOAP_CMAC xsd__short : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__short; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short, default initialized and not managed by a soap context
        virtual xsd__short *soap_alloc(void) const { return SOAP_NEW(xsd__short); }
      public:
        /// Constructor with initializations
        xsd__short()
        {
          __item = (short)0;
        }
        virtual ~xsd__short() { }
        /// Friend allocator used by soap_new_xsd__short(struct soap*, int)
        friend SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:285 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (41)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string()
        {
          __item = (char *)0;
        }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:292 */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (42)
/* Type xsd__unsignedByte_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte_, default initialized and not managed by a soap context
        virtual xsd__unsignedByte_ *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedByte_); }
      public:
        /// Constructor with initializations
        xsd__unsignedByte_()
        {
          __item = (unsigned char)0;
        }
        virtual ~xsd__unsignedByte_() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:299 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (43)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt()
        {
          __item = (unsigned int)0;
        }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:306 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (44)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong()
        {
          __item = (ULONG64)0;
        }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:313 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (46)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort()
        {
          __item = (unsigned short)0;
        }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:664 */
#ifndef SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_
#define SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_ (147)
/* Type ns3__EventData_x002eCustomMessageJustificationType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns3:EventData.CustomMessageJustificationType': */
class SOAP_CMAC ns3__EventData_x002eCustomMessageJustificationType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns3:EventData.CustomMessageJustificationType' wrapped by this struct
        enum ns3__EventData_x002eCustomMessageJustificationType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__EventData_x002eCustomMessageJustificationType_, default initialized and not managed by a soap context
        virtual ns3__EventData_x002eCustomMessageJustificationType_ *soap_alloc(void) const { return SOAP_NEW(ns3__EventData_x002eCustomMessageJustificationType_); }
      public:
        /// Constructor with initializations
        ns3__EventData_x002eCustomMessageJustificationType_()
        {
          __item = (enum ns3__EventData_x002eCustomMessageJustificationType)0;
        }
        virtual ~ns3__EventData_x002eCustomMessageJustificationType_() { }
        /// Friend allocator used by soap_new_ns3__EventData_x002eCustomMessageJustificationType_(struct soap*, int)
        friend SOAP_FMAC1 ns3__EventData_x002eCustomMessageJustificationType_ * SOAP_FMAC2 soap_instantiate_ns3__EventData_x002eCustomMessageJustificationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:683 */
#ifndef SOAP_TYPE_ns4__char__
#define SOAP_TYPE_ns4__char__ (149)
/* Type ns4__char__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns4:char': */
class SOAP_CMAC ns4__char__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns4:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__char__
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__char__, default initialized and not managed by a soap context
        virtual ns4__char__ *soap_alloc(void) const { return SOAP_NEW(ns4__char__); }
      public:
        /// Constructor with initializations
        ns4__char__()
        {
          __item = (int)0;
        }
        virtual ~ns4__char__() { }
        /// Friend allocator used by soap_new_ns4__char__(struct soap*, int)
        friend SOAP_FMAC1 ns4__char__ * SOAP_FMAC2 soap_instantiate_ns4__char__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:696 */
#ifndef SOAP_TYPE_ns4__duration__
#define SOAP_TYPE_ns4__duration__ (151)
/* Type ns4__duration__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns4:duration': */
class SOAP_CMAC ns4__duration__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns4:duration' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__duration__
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__duration__, default initialized and not managed by a soap context
        virtual ns4__duration__ *soap_alloc(void) const { return SOAP_NEW(ns4__duration__); }
      public:
        /// Constructor with initializations
        ns4__duration__()
        {
          __item = (char *)0;
        }
        virtual ~ns4__duration__() { }
        /// Friend allocator used by soap_new_ns4__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns4__duration__ * SOAP_FMAC2 soap_instantiate_ns4__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:708 */
#ifndef SOAP_TYPE_ns4__guid__
#define SOAP_TYPE_ns4__guid__ (153)
/* Type ns4__guid__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns4:guid': */
class SOAP_CMAC ns4__guid__ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns4:guid' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_ns4__guid__
        virtual int soap_type(void) const { return SOAP_TYPE_ns4__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__guid__, default initialized and not managed by a soap context
        virtual ns4__guid__ *soap_alloc(void) const { return SOAP_NEW(ns4__guid__); }
      public:
        /// Constructor with initializations
        ns4__guid__()
        {
          __item = (char *)0;
        }
        virtual ~ns4__guid__() { }
        /// Friend allocator used by soap_new_ns4__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns4__guid__ * SOAP_FMAC2 soap_instantiate_ns4__guid__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:327 */
#ifndef SOAP_TYPE__ns1__Checkin
#define SOAP_TYPE__ns1__Checkin (48)
/* complex XSD type 'ns1:Checkin': */
class SOAP_CMAC _ns1__Checkin {
      public:
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:lastSequenceNumber' of XSD type 'xsd:int'
        int *lastSequenceNumber;
        /// Optional element 'ns1:lastType' of XSD type 'xsd:int'
        int *lastType;
        /// Optional element 'ns1:lastID' of XSD type 'xsd:int'
        int *lastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Checkin
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Checkin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Checkin, default initialized and not managed by a soap context
        virtual _ns1__Checkin *soap_alloc(void) const { return SOAP_NEW(_ns1__Checkin); }
      public:
        /// Constructor with initializations
        _ns1__Checkin()
        {
          slotmastID = (int *)0;
          ocr = (char *)0;
          lastTimeStamp = (xsd__base64Binary *)0;
          lastSequenceNumber = (int *)0;
          lastType = (int *)0;
          lastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Checkin() { }
        /// Friend allocator used by soap_new__ns1__Checkin(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Checkin * SOAP_FMAC2 soap_instantiate__ns1__Checkin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:330 */
#ifndef SOAP_TYPE__ns1__CheckinResponse
#define SOAP_TYPE__ns1__CheckinResponse (49)
/* complex XSD type 'ns1:CheckinResponse': */
class SOAP_CMAC _ns1__CheckinResponse {
      public:
        /// Optional element 'ns1:CheckinResult' of XSD type 'xsd:boolean'
        bool *CheckinResult;
        /// Optional element 'ns1:nextTimestamps' of XSD type 'ns2:ArrayOfbase64Binary'
        ns2__ArrayOfbase64Binary *nextTimestamps;
        /// Optional element 'ns1:nextSequenceNumbers' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *nextSequenceNumbers;
        /// Optional element 'ns1:nextTypes' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *nextTypes;
        /// Optional element 'ns1:nextIDs' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *nextIDs;
        /// Optional element 'ns1:foundCount' of XSD type 'xsd:int'
        int *foundCount;
        /// Optional element 'ns1:hasMore' of XSD type 'xsd:boolean'
        bool *hasMore;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CheckinResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CheckinResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CheckinResponse, default initialized and not managed by a soap context
        virtual _ns1__CheckinResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CheckinResponse); }
      public:
        /// Constructor with initializations
        _ns1__CheckinResponse()
        {
          CheckinResult = (bool *)0;
          nextTimestamps = (ns2__ArrayOfbase64Binary *)0;
          nextSequenceNumbers = (ns2__ArrayOfint *)0;
          nextTypes = (ns2__ArrayOfint *)0;
          nextIDs = (ns2__ArrayOfint *)0;
          foundCount = (int *)0;
          hasMore = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CheckinResponse() { }
        /// Friend allocator used by soap_new__ns1__CheckinResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CheckinResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckinResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:333 */
#ifndef SOAP_TYPE__ns1__GetEventStartNotification
#define SOAP_TYPE__ns1__GetEventStartNotification (50)
/* complex XSD type 'ns1:GetEventStartNotification': */
class SOAP_CMAC _ns1__GetEventStartNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventStartNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventStartNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventStartNotification, default initialized and not managed by a soap context
        virtual _ns1__GetEventStartNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventStartNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetEventStartNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventStartNotification() { }
        /// Friend allocator used by soap_new__ns1__GetEventStartNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventStartNotification * SOAP_FMAC2 soap_instantiate__ns1__GetEventStartNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:336 */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationResponse
#define SOAP_TYPE__ns1__GetEventStartNotificationResponse (51)
/* complex XSD type 'ns1:GetEventStartNotificationResponse': */
class SOAP_CMAC _ns1__GetEventStartNotificationResponse {
      public:
        /// Optional element 'ns1:GetEventStartNotificationResult' of XSD type 'xsd:boolean'
        bool *GetEventStartNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:contentId' of XSD type 'xsd:int'
        int *contentId;
        /// Optional element 'ns1:triggerType' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *triggerType;
        /// Optional element 'ns1:triggerMin' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMin;
        /// Optional element 'ns1:triggerMax' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMax;
        /// Optional element 'ns1:numTriggers' of XSD type 'xsd:int'
        int *numTriggers;
        /// Optional element 'ns1:lastTriggeredEventID' of XSD type 'xsd:int'
        int *lastTriggeredEventID;
        /// Optional element 'ns1:includeCarded' of XSD type 'xsd:boolean'
        bool *includeCarded;
        /// Optional element 'ns1:includeUncarded' of XSD type 'xsd:boolean'
        bool *includeUncarded;
        /// Optional element 'ns1:includeInRandomSelection' of XSD type 'xsd:boolean'
        bool *includeInRandomSelection;
        /// Optional element 'ns1:groupCumulative' of XSD type 'xsd:boolean'
        bool *groupCumulative;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventStartNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventStartNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventStartNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEventStartNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventStartNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEventStartNotificationResponse()
        {
          GetEventStartNotificationResult = (bool *)0;
          eventId = (int *)0;
          contentId = (int *)0;
          triggerType = (ns2__ArrayOfint *)0;
          triggerMin = (ns2__ArrayOflong *)0;
          triggerMax = (ns2__ArrayOflong *)0;
          numTriggers = (int *)0;
          lastTriggeredEventID = (int *)0;
          includeCarded = (bool *)0;
          includeUncarded = (bool *)0;
          includeInRandomSelection = (bool *)0;
          groupCumulative = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventStartNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEventStartNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventStartNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEventStartNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:339 */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationV25
#define SOAP_TYPE__ns1__GetEventStartNotificationV25 (52)
/* complex XSD type 'ns1:GetEventStartNotificationV25': */
class SOAP_CMAC _ns1__GetEventStartNotificationV25 {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventStartNotificationV25
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventStartNotificationV25; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventStartNotificationV25, default initialized and not managed by a soap context
        virtual _ns1__GetEventStartNotificationV25 *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventStartNotificationV25); }
      public:
        /// Constructor with initializations
        _ns1__GetEventStartNotificationV25()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventStartNotificationV25() { }
        /// Friend allocator used by soap_new__ns1__GetEventStartNotificationV25(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventStartNotificationV25 * SOAP_FMAC2 soap_instantiate__ns1__GetEventStartNotificationV25(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:342 */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationV25Response
#define SOAP_TYPE__ns1__GetEventStartNotificationV25Response (53)
/* complex XSD type 'ns1:GetEventStartNotificationV25Response': */
class SOAP_CMAC _ns1__GetEventStartNotificationV25Response {
      public:
        /// Optional element 'ns1:GetEventStartNotificationV25Result' of XSD type 'xsd:boolean'
        bool *GetEventStartNotificationV25Result;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:contentId' of XSD type 'xsd:int'
        int *contentId;
        /// Optional element 'ns1:triggerType' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *triggerType;
        /// Optional element 'ns1:triggerMin' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMin;
        /// Optional element 'ns1:triggerMax' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMax;
        /// Optional element 'ns1:numTriggers' of XSD type 'xsd:int'
        int *numTriggers;
        /// Optional element 'ns1:lastTriggeredEventID' of XSD type 'xsd:int'
        int *lastTriggeredEventID;
        /// Optional element 'ns1:includeCarded' of XSD type 'xsd:boolean'
        bool *includeCarded;
        /// Optional element 'ns1:includeUncarded' of XSD type 'xsd:boolean'
        bool *includeUncarded;
        /// Optional element 'ns1:includeInRandomSelection' of XSD type 'xsd:boolean'
        bool *includeInRandomSelection;
        /// Optional element 'ns1:groupCumulative' of XSD type 'xsd:boolean'
        bool *groupCumulative;
        /// Optional element 'ns1:cmpCoinInUsage' of XSD type 'xsd:boolean'
        bool *cmpCoinInUsage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventStartNotificationV25Response
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventStartNotificationV25Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventStartNotificationV25Response, default initialized and not managed by a soap context
        virtual _ns1__GetEventStartNotificationV25Response *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventStartNotificationV25Response); }
      public:
        /// Constructor with initializations
        _ns1__GetEventStartNotificationV25Response()
        {
          GetEventStartNotificationV25Result = (bool *)0;
          eventId = (int *)0;
          contentId = (int *)0;
          triggerType = (ns2__ArrayOfint *)0;
          triggerMin = (ns2__ArrayOflong *)0;
          triggerMax = (ns2__ArrayOflong *)0;
          numTriggers = (int *)0;
          lastTriggeredEventID = (int *)0;
          includeCarded = (bool *)0;
          includeUncarded = (bool *)0;
          includeInRandomSelection = (bool *)0;
          groupCumulative = (bool *)0;
          cmpCoinInUsage = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventStartNotificationV25Response() { }
        /// Friend allocator used by soap_new__ns1__GetEventStartNotificationV25Response(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventStartNotificationV25Response * SOAP_FMAC2 soap_instantiate__ns1__GetEventStartNotificationV25Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:345 */
#ifndef SOAP_TYPE__ns1__GetCMPStatusNotification
#define SOAP_TYPE__ns1__GetCMPStatusNotification (54)
/* complex XSD type 'ns1:GetCMPStatusNotification': */
class SOAP_CMAC _ns1__GetCMPStatusNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCMPStatusNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCMPStatusNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCMPStatusNotification, default initialized and not managed by a soap context
        virtual _ns1__GetCMPStatusNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCMPStatusNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetCMPStatusNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCMPStatusNotification() { }
        /// Friend allocator used by soap_new__ns1__GetCMPStatusNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCMPStatusNotification * SOAP_FMAC2 soap_instantiate__ns1__GetCMPStatusNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:348 */
#ifndef SOAP_TYPE__ns1__GetCMPStatusNotificationResponse
#define SOAP_TYPE__ns1__GetCMPStatusNotificationResponse (55)
/* complex XSD type 'ns1:GetCMPStatusNotificationResponse': */
class SOAP_CMAC _ns1__GetCMPStatusNotificationResponse {
      public:
        /// Optional element 'ns1:GetCMPStatusNotificationResult' of XSD type 'xsd:boolean'
        bool *GetCMPStatusNotificationResult;
        /// Optional element 'ns1:cmpActive' of XSD type 'xsd:boolean'
        bool *cmpActive;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCMPStatusNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCMPStatusNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCMPStatusNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCMPStatusNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCMPStatusNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCMPStatusNotificationResponse()
        {
          GetCMPStatusNotificationResult = (bool *)0;
          cmpActive = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCMPStatusNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCMPStatusNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCMPStatusNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCMPStatusNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:351 */
#ifndef SOAP_TYPE__ns1__GetSentinelConfigNotification
#define SOAP_TYPE__ns1__GetSentinelConfigNotification (56)
/* complex XSD type 'ns1:GetSentinelConfigNotification': */
class SOAP_CMAC _ns1__GetSentinelConfigNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSentinelConfigNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSentinelConfigNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSentinelConfigNotification, default initialized and not managed by a soap context
        virtual _ns1__GetSentinelConfigNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSentinelConfigNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetSentinelConfigNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSentinelConfigNotification() { }
        /// Friend allocator used by soap_new__ns1__GetSentinelConfigNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSentinelConfigNotification * SOAP_FMAC2 soap_instantiate__ns1__GetSentinelConfigNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:354 */
#ifndef SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse
#define SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse (57)
/* complex XSD type 'ns1:GetSentinelConfigNotificationResponse': */
class SOAP_CMAC _ns1__GetSentinelConfigNotificationResponse {
      public:
        /// Optional element 'ns1:GetSentinelConfigNotificationResult' of XSD type 'xsd:boolean'
        bool *GetSentinelConfigNotificationResult;
        /// Optional element 'ns1:parameters' of XSD type 'ns2:ArrayOfKeyValueOfstringstring'
        ns2__ArrayOfKeyValueOfstringstring *parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSentinelConfigNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSentinelConfigNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSentinelConfigNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSentinelConfigNotificationResponse()
        {
          GetSentinelConfigNotificationResult = (bool *)0;
          parameters = (ns2__ArrayOfKeyValueOfstringstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSentinelConfigNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSentinelConfigNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSentinelConfigNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSentinelConfigNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:357 */
#ifndef SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom (58)
/* complex XSD type 'ns1:GetSplashdownTriggeredEventNotificationCustom': */
class SOAP_CMAC _ns1__GetSplashdownTriggeredEventNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownTriggeredEventNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownTriggeredEventNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownTriggeredEventNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownTriggeredEventNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownTriggeredEventNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:360 */
#ifndef SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse (59)
/* complex XSD type 'ns1:GetSplashdownTriggeredEventNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetSplashdownTriggeredEventNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetSplashdownTriggeredEventNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetSplashdownTriggeredEventNotificationCustomResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventId' of XSD type 'xsd:int'
        int *triggeredEventId;
        /// Optional element 'ns1:triggerType' of XSD type 'ns2:ArrayOfint'
        ns2__ArrayOfint *triggerType;
        /// Optional element 'ns1:triggerMin' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMin;
        /// Optional element 'ns1:triggerMax' of XSD type 'ns2:ArrayOflong'
        ns2__ArrayOflong *triggerMax;
        /// Optional element 'ns1:numTriggers' of XSD type 'xsd:int'
        int *numTriggers;
        /// Optional element 'ns1:duration' of XSD type 'xsd:int'
        int *duration;
        /// Optional element 'ns1:groupCumulative' of XSD type 'xsd:boolean'
        bool *groupCumulative;
        /// Optional element 'ns1:pointsToBeAwarded' of XSD type 'xsd:boolean'
        bool *pointsToBeAwarded;
        /// Optional element 'ns1:customScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customScreen;
        /// Optional element 'ns1:customCelebrationScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customCelebrationScreen;
        /// Optional element 'ns1:customFinaleScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customFinaleScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownTriggeredEventNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownTriggeredEventNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownTriggeredEventNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownTriggeredEventNotificationCustomResponse()
        {
          GetSplashdownTriggeredEventNotificationCustomResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventId = (int *)0;
          triggerType = (ns2__ArrayOfint *)0;
          triggerMin = (ns2__ArrayOflong *)0;
          triggerMax = (ns2__ArrayOflong *)0;
          numTriggers = (int *)0;
          duration = (int *)0;
          groupCumulative = (bool *)0;
          pointsToBeAwarded = (bool *)0;
          customScreen = (ns3__CustomMessageScreen *)0;
          customCelebrationScreen = (ns3__CustomMessageScreen *)0;
          customFinaleScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownTriggeredEventNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownTriggeredEventNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownTriggeredEventNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownTriggeredEventNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:363 */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom (60)
/* complex XSD type 'ns1:GetSplashdownAwardNotificationCustom': */
class SOAP_CMAC _ns1__GetSplashdownAwardNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownAwardNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownAwardNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownAwardNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownAwardNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownAwardNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownAwardNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownAwardNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:366 */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse (61)
/* complex XSD type 'ns1:GetSplashdownAwardNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetSplashdownAwardNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetSplashdownAwardNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetSplashdownAwardNotificationCustomResult;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:showAward' of XSD type 'xsd:boolean'
        bool *showAward;
        /// Optional element 'ns1:isTriggerAward' of XSD type 'xsd:boolean'
        bool *isTriggerAward;
        /// Optional element 'ns1:awardAmount' of XSD type 'xsd:int'
        int *awardAmount;
        /// Optional element 'ns1:customScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownAwardNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownAwardNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownAwardNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownAwardNotificationCustomResponse()
        {
          GetSplashdownAwardNotificationCustomResult = (bool *)0;
          triggeredEventID = (int *)0;
          showAward = (bool *)0;
          isTriggerAward = (bool *)0;
          awardAmount = (int *)0;
          customScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownAwardNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownAwardNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownAwardNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownAwardNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:369 */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData (62)
/* complex XSD type 'ns1:GetSplashdownAwardNotificationCustomWithMediaData': */
class SOAP_CMAC _ns1__GetSplashdownAwardNotificationCustomWithMediaData {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownAwardNotificationCustomWithMediaData, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownAwardNotificationCustomWithMediaData *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownAwardNotificationCustomWithMediaData); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownAwardNotificationCustomWithMediaData()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownAwardNotificationCustomWithMediaData() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:372 */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse (63)
/* complex XSD type 'ns1:GetSplashdownAwardNotificationCustomWithMediaDataResponse': */
class SOAP_CMAC _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse {
      public:
        /// Optional element 'ns1:GetSplashdownAwardNotificationCustomWithMediaDataResult' of XSD type 'xsd:boolean'
        bool *GetSplashdownAwardNotificationCustomWithMediaDataResult;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:showAward' of XSD type 'xsd:boolean'
        bool *showAward;
        /// Optional element 'ns1:isTriggerAward' of XSD type 'xsd:boolean'
        bool *isTriggerAward;
        /// Optional element 'ns1:awardAmount' of XSD type 'xsd:int'
        int *awardAmount;
        /// Optional element 'ns1:customScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customScreen;
        /// Optional element 'ns1:mediaData' of XSD type 'xsd:string'
        char *mediaData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse()
        {
          GetSplashdownAwardNotificationCustomWithMediaDataResult = (bool *)0;
          triggeredEventID = (int *)0;
          showAward = (bool *)0;
          isTriggerAward = (bool *)0;
          awardAmount = (int *)0;
          customScreen = (ns3__CustomMessageScreen *)0;
          mediaData = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:375 */
#ifndef SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom (64)
/* complex XSD type 'ns1:GetRicochetTriggeredEventNotificationCustom': */
class SOAP_CMAC _ns1__GetRicochetTriggeredEventNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetTriggeredEventNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetTriggeredEventNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetTriggeredEventNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetTriggeredEventNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetTriggeredEventNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:378 */
#ifndef SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse (65)
/* complex XSD type 'ns1:GetRicochetTriggeredEventNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetRicochetTriggeredEventNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetRicochetTriggeredEventNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetRicochetTriggeredEventNotificationCustomResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:show' of XSD type 'xsd:boolean'
        bool *show;
        /// Optional element 'ns1:triggerScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *triggerScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetTriggeredEventNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetTriggeredEventNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetTriggeredEventNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetTriggeredEventNotificationCustomResponse()
        {
          GetRicochetTriggeredEventNotificationCustomResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventID = (int *)0;
          show = (bool *)0;
          triggerScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetTriggeredEventNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetTriggeredEventNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetTriggeredEventNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetTriggeredEventNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:381 */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom (66)
/* complex XSD type 'ns1:GetRicochetAwardNotificationCustom': */
class SOAP_CMAC _ns1__GetRicochetAwardNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetAwardNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetAwardNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetAwardNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetAwardNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetAwardNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetAwardNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetAwardNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:384 */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse (67)
/* complex XSD type 'ns1:GetRicochetAwardNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetRicochetAwardNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetRicochetAwardNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetRicochetAwardNotificationCustomResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:showAward' of XSD type 'xsd:boolean'
        bool *showAward;
        /// Optional element 'ns1:customScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetAwardNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetAwardNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetAwardNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetAwardNotificationCustomResponse()
        {
          GetRicochetAwardNotificationCustomResult = (bool *)0;
          eventId = (int *)0;
          showAward = (bool *)0;
          customScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetAwardNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetAwardNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetAwardNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetAwardNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:387 */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData (68)
/* complex XSD type 'ns1:GetRicochetAwardNotificationCustomWithMediaData': */
class SOAP_CMAC _ns1__GetRicochetAwardNotificationCustomWithMediaData {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetAwardNotificationCustomWithMediaData, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetAwardNotificationCustomWithMediaData *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetAwardNotificationCustomWithMediaData); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetAwardNotificationCustomWithMediaData()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetAwardNotificationCustomWithMediaData() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:390 */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse (69)
/* complex XSD type 'ns1:GetRicochetAwardNotificationCustomWithMediaDataResponse': */
class SOAP_CMAC _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse {
      public:
        /// Optional element 'ns1:GetRicochetAwardNotificationCustomWithMediaDataResult' of XSD type 'xsd:boolean'
        bool *GetRicochetAwardNotificationCustomWithMediaDataResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:showAward' of XSD type 'xsd:boolean'
        bool *showAward;
        /// Optional element 'ns1:customScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customScreen;
        /// Optional element 'ns1:mediaData' of XSD type 'xsd:string'
        char *mediaData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse, default initialized and not managed by a soap context
        virtual _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse()
        {
          GetRicochetAwardNotificationCustomWithMediaDataResult = (bool *)0;
          eventId = (int *)0;
          showAward = (bool *)0;
          customScreen = (ns3__CustomMessageScreen *)0;
          mediaData = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse() { }
        /// Friend allocator used by soap_new__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:393 */
#ifndef SOAP_TYPE__ns1__GetJackpotAnnouncementNotification
#define SOAP_TYPE__ns1__GetJackpotAnnouncementNotification (70)
/* complex XSD type 'ns1:GetJackpotAnnouncementNotification': */
class SOAP_CMAC _ns1__GetJackpotAnnouncementNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetJackpotAnnouncementNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetJackpotAnnouncementNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetJackpotAnnouncementNotification, default initialized and not managed by a soap context
        virtual _ns1__GetJackpotAnnouncementNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetJackpotAnnouncementNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetJackpotAnnouncementNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetJackpotAnnouncementNotification() { }
        /// Friend allocator used by soap_new__ns1__GetJackpotAnnouncementNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetJackpotAnnouncementNotification * SOAP_FMAC2 soap_instantiate__ns1__GetJackpotAnnouncementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:396 */
#ifndef SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse
#define SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse (71)
/* complex XSD type 'ns1:GetJackpotAnnouncementNotificationResponse': */
class SOAP_CMAC _ns1__GetJackpotAnnouncementNotificationResponse {
      public:
        /// Optional element 'ns1:GetJackpotAnnouncementNotificationResult' of XSD type 'xsd:boolean'
        bool *GetJackpotAnnouncementNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:carded' of XSD type 'xsd:boolean'
        bool *carded;
        /// Optional element 'ns1:screen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *screen;
        /// Optional element 'ns1:showAward' of XSD type 'xsd:boolean'
        bool *showAward;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetJackpotAnnouncementNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetJackpotAnnouncementNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetJackpotAnnouncementNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetJackpotAnnouncementNotificationResponse()
        {
          GetJackpotAnnouncementNotificationResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventID = (int *)0;
          carded = (bool *)0;
          screen = (ns3__CustomMessageScreen *)0;
          showAward = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetJackpotAnnouncementNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetJackpotAnnouncementNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetJackpotAnnouncementNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetJackpotAnnouncementNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:399 */
#ifndef SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification
#define SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification (72)
/* complex XSD type 'ns1:GetTriggerlessAnnouncementNotification': */
class SOAP_CMAC _ns1__GetTriggerlessAnnouncementNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTriggerlessAnnouncementNotification, default initialized and not managed by a soap context
        virtual _ns1__GetTriggerlessAnnouncementNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTriggerlessAnnouncementNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetTriggerlessAnnouncementNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetTriggerlessAnnouncementNotification() { }
        /// Friend allocator used by soap_new__ns1__GetTriggerlessAnnouncementNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTriggerlessAnnouncementNotification * SOAP_FMAC2 soap_instantiate__ns1__GetTriggerlessAnnouncementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:402 */
#ifndef SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse
#define SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse (73)
/* complex XSD type 'ns1:GetTriggerlessAnnouncementNotificationResponse': */
class SOAP_CMAC _ns1__GetTriggerlessAnnouncementNotificationResponse {
      public:
        /// Optional element 'ns1:GetTriggerlessAnnouncementNotificationResult' of XSD type 'xsd:boolean'
        bool *GetTriggerlessAnnouncementNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:carded' of XSD type 'xsd:boolean'
        bool *carded;
        /// Optional element 'ns1:screen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *screen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTriggerlessAnnouncementNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetTriggerlessAnnouncementNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTriggerlessAnnouncementNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetTriggerlessAnnouncementNotificationResponse()
        {
          GetTriggerlessAnnouncementNotificationResult = (bool *)0;
          eventId = (int *)0;
          carded = (bool *)0;
          screen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetTriggerlessAnnouncementNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetTriggerlessAnnouncementNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTriggerlessAnnouncementNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTriggerlessAnnouncementNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:405 */
#ifndef SOAP_TYPE__ns1__GetExternalPaidNotification
#define SOAP_TYPE__ns1__GetExternalPaidNotification (74)
/* complex XSD type 'ns1:GetExternalPaidNotification': */
class SOAP_CMAC _ns1__GetExternalPaidNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetExternalPaidNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetExternalPaidNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetExternalPaidNotification, default initialized and not managed by a soap context
        virtual _ns1__GetExternalPaidNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetExternalPaidNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetExternalPaidNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetExternalPaidNotification() { }
        /// Friend allocator used by soap_new__ns1__GetExternalPaidNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetExternalPaidNotification * SOAP_FMAC2 soap_instantiate__ns1__GetExternalPaidNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:408 */
#ifndef SOAP_TYPE__ns1__GetExternalPaidNotificationResponse
#define SOAP_TYPE__ns1__GetExternalPaidNotificationResponse (75)
/* complex XSD type 'ns1:GetExternalPaidNotificationResponse': */
class SOAP_CMAC _ns1__GetExternalPaidNotificationResponse {
      public:
        /// Optional element 'ns1:GetExternalPaidNotificationResult' of XSD type 'xsd:boolean'
        bool *GetExternalPaidNotificationResult;
        /// Optional element 'ns1:BonusAmount' of XSD type 'xsd:double'
        double *BonusAmount;
        /// Optional element 'ns1:AwardID' of XSD type 'xsd:int'
        int *AwardID;
        /// Optional element 'ns1:TransactionID' of XSD type 'xsd:string'
        char *TransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetExternalPaidNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetExternalPaidNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetExternalPaidNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetExternalPaidNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetExternalPaidNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetExternalPaidNotificationResponse()
        {
          GetExternalPaidNotificationResult = (bool *)0;
          BonusAmount = (double *)0;
          AwardID = (int *)0;
          TransactionID = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetExternalPaidNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetExternalPaidNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetExternalPaidNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetExternalPaidNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:411 */
#ifndef SOAP_TYPE__ns1__GetTriggerRejectedNotification
#define SOAP_TYPE__ns1__GetTriggerRejectedNotification (76)
/* complex XSD type 'ns1:GetTriggerRejectedNotification': */
class SOAP_CMAC _ns1__GetTriggerRejectedNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTriggerRejectedNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTriggerRejectedNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTriggerRejectedNotification, default initialized and not managed by a soap context
        virtual _ns1__GetTriggerRejectedNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTriggerRejectedNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetTriggerRejectedNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetTriggerRejectedNotification() { }
        /// Friend allocator used by soap_new__ns1__GetTriggerRejectedNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTriggerRejectedNotification * SOAP_FMAC2 soap_instantiate__ns1__GetTriggerRejectedNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:414 */
#ifndef SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse
#define SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse (77)
/* complex XSD type 'ns1:GetTriggerRejectedNotificationResponse': */
class SOAP_CMAC _ns1__GetTriggerRejectedNotificationResponse {
      public:
        /// Optional element 'ns1:GetTriggerRejectedNotificationResult' of XSD type 'xsd:boolean'
        bool *GetTriggerRejectedNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:lastTriggeredEventId' of XSD type 'xsd:int'
        int *lastTriggeredEventId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTriggerRejectedNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetTriggerRejectedNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetTriggerRejectedNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetTriggerRejectedNotificationResponse()
        {
          GetTriggerRejectedNotificationResult = (bool *)0;
          eventId = (int *)0;
          lastTriggeredEventId = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetTriggerRejectedNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetTriggerRejectedNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTriggerRejectedNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTriggerRejectedNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:417 */
#ifndef SOAP_TYPE__ns1__GetSpeedMediaVersion
#define SOAP_TYPE__ns1__GetSpeedMediaVersion (78)
/* complex XSD type 'ns1:GetSpeedMediaVersion': */
class SOAP_CMAC _ns1__GetSpeedMediaVersion {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSpeedMediaVersion
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSpeedMediaVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSpeedMediaVersion, default initialized and not managed by a soap context
        virtual _ns1__GetSpeedMediaVersion *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSpeedMediaVersion); }
      public:
        /// Constructor with initializations
        _ns1__GetSpeedMediaVersion()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSpeedMediaVersion() { }
        /// Friend allocator used by soap_new__ns1__GetSpeedMediaVersion(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSpeedMediaVersion * SOAP_FMAC2 soap_instantiate__ns1__GetSpeedMediaVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:420 */
#ifndef SOAP_TYPE__ns1__GetSpeedMediaVersionResponse
#define SOAP_TYPE__ns1__GetSpeedMediaVersionResponse (79)
/* complex XSD type 'ns1:GetSpeedMediaVersionResponse': */
class SOAP_CMAC _ns1__GetSpeedMediaVersionResponse {
      public:
        /// Optional element 'ns1:GetSpeedMediaVersionResult' of XSD type 'xsd:boolean'
        bool *GetSpeedMediaVersionResult;
        /// Optional element 'ns1:major' of XSD type 'xsd:int'
        int *major;
        /// Optional element 'ns1:minor' of XSD type 'xsd:int'
        int *minor;
        /// Optional element 'ns1:revision' of XSD type 'xsd:int'
        int *revision;
        /// Optional element 'ns1:build' of XSD type 'xsd:int'
        int *build;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetSpeedMediaVersionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetSpeedMediaVersionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetSpeedMediaVersionResponse, default initialized and not managed by a soap context
        virtual _ns1__GetSpeedMediaVersionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetSpeedMediaVersionResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetSpeedMediaVersionResponse()
        {
          GetSpeedMediaVersionResult = (bool *)0;
          major = (int *)0;
          minor = (int *)0;
          revision = (int *)0;
          build = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetSpeedMediaVersionResponse() { }
        /// Friend allocator used by soap_new__ns1__GetSpeedMediaVersionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetSpeedMediaVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetSpeedMediaVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:423 */
#ifndef SOAP_TYPE__ns1__CardIn
#define SOAP_TYPE__ns1__CardIn (80)
/* complex XSD type 'ns1:CardIn': */
class SOAP_CMAC _ns1__CardIn {
      public:
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:SlotmastID' of XSD type 'xsd:int'
        int *SlotmastID;
        /// Optional element 'ns1:hasPlayedGame' of XSD type 'xsd:boolean'
        bool *hasPlayedGame;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CardIn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CardIn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CardIn, default initialized and not managed by a soap context
        virtual _ns1__CardIn *soap_alloc(void) const { return SOAP_NEW(_ns1__CardIn); }
      public:
        /// Constructor with initializations
        _ns1__CardIn()
        {
          OCR = (char *)0;
          SlotmastID = (int *)0;
          hasPlayedGame = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CardIn() { }
        /// Friend allocator used by soap_new__ns1__CardIn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CardIn * SOAP_FMAC2 soap_instantiate__ns1__CardIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:426 */
#ifndef SOAP_TYPE__ns1__CardInResponse
#define SOAP_TYPE__ns1__CardInResponse (81)
/* complex XSD type 'ns1:CardInResponse': */
class SOAP_CMAC _ns1__CardInResponse {
      public:
        /// Optional element 'ns1:CardInResult' of XSD type 'xsd:boolean'
        bool *CardInResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CardInResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CardInResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CardInResponse, default initialized and not managed by a soap context
        virtual _ns1__CardInResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CardInResponse); }
      public:
        /// Constructor with initializations
        _ns1__CardInResponse()
        {
          CardInResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CardInResponse() { }
        /// Friend allocator used by soap_new__ns1__CardInResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CardInResponse * SOAP_FMAC2 soap_instantiate__ns1__CardInResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:429 */
#ifndef SOAP_TYPE__ns1__CardOut
#define SOAP_TYPE__ns1__CardOut (82)
/* complex XSD type 'ns1:CardOut': */
class SOAP_CMAC _ns1__CardOut {
      public:
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:SlotmastID' of XSD type 'xsd:int'
        int *SlotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CardOut
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CardOut; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CardOut, default initialized and not managed by a soap context
        virtual _ns1__CardOut *soap_alloc(void) const { return SOAP_NEW(_ns1__CardOut); }
      public:
        /// Constructor with initializations
        _ns1__CardOut()
        {
          OCR = (char *)0;
          SlotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CardOut() { }
        /// Friend allocator used by soap_new__ns1__CardOut(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CardOut * SOAP_FMAC2 soap_instantiate__ns1__CardOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:432 */
#ifndef SOAP_TYPE__ns1__CardOutResponse
#define SOAP_TYPE__ns1__CardOutResponse (83)
/* complex XSD type 'ns1:CardOutResponse': */
class SOAP_CMAC _ns1__CardOutResponse {
      public:
        /// Optional element 'ns1:CardOutResult' of XSD type 'xsd:boolean'
        bool *CardOutResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CardOutResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CardOutResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CardOutResponse, default initialized and not managed by a soap context
        virtual _ns1__CardOutResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CardOutResponse); }
      public:
        /// Constructor with initializations
        _ns1__CardOutResponse()
        {
          CardOutResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CardOutResponse() { }
        /// Friend allocator used by soap_new__ns1__CardOutResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CardOutResponse * SOAP_FMAC2 soap_instantiate__ns1__CardOutResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:435 */
#ifndef SOAP_TYPE__ns1__GamePlayedAfterCardIn
#define SOAP_TYPE__ns1__GamePlayedAfterCardIn (84)
/* complex XSD type 'ns1:GamePlayedAfterCardIn': */
class SOAP_CMAC _ns1__GamePlayedAfterCardIn {
      public:
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:SlotmastID' of XSD type 'xsd:int'
        int *SlotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GamePlayedAfterCardIn
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GamePlayedAfterCardIn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GamePlayedAfterCardIn, default initialized and not managed by a soap context
        virtual _ns1__GamePlayedAfterCardIn *soap_alloc(void) const { return SOAP_NEW(_ns1__GamePlayedAfterCardIn); }
      public:
        /// Constructor with initializations
        _ns1__GamePlayedAfterCardIn()
        {
          OCR = (char *)0;
          SlotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GamePlayedAfterCardIn() { }
        /// Friend allocator used by soap_new__ns1__GamePlayedAfterCardIn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GamePlayedAfterCardIn * SOAP_FMAC2 soap_instantiate__ns1__GamePlayedAfterCardIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:438 */
#ifndef SOAP_TYPE__ns1__GamePlayedAfterCardInResponse
#define SOAP_TYPE__ns1__GamePlayedAfterCardInResponse (85)
/* complex XSD type 'ns1:GamePlayedAfterCardInResponse': */
class SOAP_CMAC _ns1__GamePlayedAfterCardInResponse {
      public:
        /// Optional element 'ns1:GamePlayedAfterCardInResult' of XSD type 'xsd:boolean'
        bool *GamePlayedAfterCardInResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GamePlayedAfterCardInResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GamePlayedAfterCardInResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GamePlayedAfterCardInResponse, default initialized and not managed by a soap context
        virtual _ns1__GamePlayedAfterCardInResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GamePlayedAfterCardInResponse); }
      public:
        /// Constructor with initializations
        _ns1__GamePlayedAfterCardInResponse()
        {
          GamePlayedAfterCardInResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GamePlayedAfterCardInResponse() { }
        /// Friend allocator used by soap_new__ns1__GamePlayedAfterCardInResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GamePlayedAfterCardInResponse * SOAP_FMAC2 soap_instantiate__ns1__GamePlayedAfterCardInResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:441 */
#ifndef SOAP_TYPE__ns1__RequestNonCardedEvents
#define SOAP_TYPE__ns1__RequestNonCardedEvents (86)
/* complex XSD type 'ns1:RequestNonCardedEvents': */
class SOAP_CMAC _ns1__RequestNonCardedEvents {
      public:
        /// Optional element 'ns1:SlotmastID' of XSD type 'xsd:int'
        int *SlotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RequestNonCardedEvents
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RequestNonCardedEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RequestNonCardedEvents, default initialized and not managed by a soap context
        virtual _ns1__RequestNonCardedEvents *soap_alloc(void) const { return SOAP_NEW(_ns1__RequestNonCardedEvents); }
      public:
        /// Constructor with initializations
        _ns1__RequestNonCardedEvents()
        {
          SlotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RequestNonCardedEvents() { }
        /// Friend allocator used by soap_new__ns1__RequestNonCardedEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RequestNonCardedEvents * SOAP_FMAC2 soap_instantiate__ns1__RequestNonCardedEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:444 */
#ifndef SOAP_TYPE__ns1__RequestNonCardedEventsResponse
#define SOAP_TYPE__ns1__RequestNonCardedEventsResponse (87)
/* complex XSD type 'ns1:RequestNonCardedEventsResponse': */
class SOAP_CMAC _ns1__RequestNonCardedEventsResponse {
      public:
        /// Optional element 'ns1:RequestNonCardedEventsResult' of XSD type 'xsd:boolean'
        bool *RequestNonCardedEventsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RequestNonCardedEventsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RequestNonCardedEventsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RequestNonCardedEventsResponse, default initialized and not managed by a soap context
        virtual _ns1__RequestNonCardedEventsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RequestNonCardedEventsResponse); }
      public:
        /// Constructor with initializations
        _ns1__RequestNonCardedEventsResponse()
        {
          RequestNonCardedEventsResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RequestNonCardedEventsResponse() { }
        /// Friend allocator used by soap_new__ns1__RequestNonCardedEventsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RequestNonCardedEventsResponse * SOAP_FMAC2 soap_instantiate__ns1__RequestNonCardedEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:447 */
#ifndef SOAP_TYPE__ns1__GetFlashStartAnnouncement
#define SOAP_TYPE__ns1__GetFlashStartAnnouncement (88)
/* complex XSD type 'ns1:GetFlashStartAnnouncement': */
class SOAP_CMAC _ns1__GetFlashStartAnnouncement {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFlashStartAnnouncement
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFlashStartAnnouncement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFlashStartAnnouncement, default initialized and not managed by a soap context
        virtual _ns1__GetFlashStartAnnouncement *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFlashStartAnnouncement); }
      public:
        /// Constructor with initializations
        _ns1__GetFlashStartAnnouncement()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFlashStartAnnouncement() { }
        /// Friend allocator used by soap_new__ns1__GetFlashStartAnnouncement(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFlashStartAnnouncement * SOAP_FMAC2 soap_instantiate__ns1__GetFlashStartAnnouncement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:450 */
#ifndef SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse
#define SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse (89)
/* complex XSD type 'ns1:GetFlashStartAnnouncementResponse': */
class SOAP_CMAC _ns1__GetFlashStartAnnouncementResponse {
      public:
        /// Optional element 'ns1:GetFlashStartAnnouncementResult' of XSD type 'xsd:boolean'
        bool *GetFlashStartAnnouncementResult;
        /// Optional element 'ns1:filename' of XSD type 'xsd:string'
        char *filename;
        /// Optional element 'ns1:size' of XSD type 'xsd:int'
        int *size;
        /// Optional element 'ns1:checksum' of XSD type 'xsd:int'
        int *checksum;
        /// Optional element 'ns1:fileID' of XSD type 'xsd:int'
        int *fileID;
        /// Optional element 'ns1:ipAddress' of XSD type 'xsd:string'
        char *ipAddress;
        /// Optional element 'ns1:port' of XSD type 'xsd:int'
        int *port;
        /// Optional element 'ns1:mediaType' of XSD type 'xsd:int'
        int *mediaType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFlashStartAnnouncementResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFlashStartAnnouncementResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFlashStartAnnouncementResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFlashStartAnnouncementResponse()
        {
          GetFlashStartAnnouncementResult = (bool *)0;
          filename = (char *)0;
          size = (int *)0;
          checksum = (int *)0;
          fileID = (int *)0;
          ipAddress = (char *)0;
          port = (int *)0;
          mediaType = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFlashStartAnnouncementResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFlashStartAnnouncementResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFlashStartAnnouncementResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFlashStartAnnouncementResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:453 */
#ifndef SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement
#define SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement (90)
/* complex XSD type 'ns1:GetFlashUdpCompleteAnnouncement': */
class SOAP_CMAC _ns1__GetFlashUdpCompleteAnnouncement {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFlashUdpCompleteAnnouncement, default initialized and not managed by a soap context
        virtual _ns1__GetFlashUdpCompleteAnnouncement *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFlashUdpCompleteAnnouncement); }
      public:
        /// Constructor with initializations
        _ns1__GetFlashUdpCompleteAnnouncement()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFlashUdpCompleteAnnouncement() { }
        /// Friend allocator used by soap_new__ns1__GetFlashUdpCompleteAnnouncement(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFlashUdpCompleteAnnouncement * SOAP_FMAC2 soap_instantiate__ns1__GetFlashUdpCompleteAnnouncement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:456 */
#ifndef SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse
#define SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse (91)
/* complex XSD type 'ns1:GetFlashUdpCompleteAnnouncementResponse': */
class SOAP_CMAC _ns1__GetFlashUdpCompleteAnnouncementResponse {
      public:
        /// Optional element 'ns1:GetFlashUdpCompleteAnnouncementResult' of XSD type 'xsd:boolean'
        bool *GetFlashUdpCompleteAnnouncementResult;
        /// Optional element 'ns1:fileID' of XSD type 'xsd:int'
        int *fileID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFlashUdpCompleteAnnouncementResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFlashUdpCompleteAnnouncementResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFlashUdpCompleteAnnouncementResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFlashUdpCompleteAnnouncementResponse()
        {
          GetFlashUdpCompleteAnnouncementResult = (bool *)0;
          fileID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFlashUdpCompleteAnnouncementResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFlashUdpCompleteAnnouncementResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFlashUdpCompleteAnnouncementResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFlashUdpCompleteAnnouncementResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:459 */
#ifndef SOAP_TYPE__ns1__GetFileInformation
#define SOAP_TYPE__ns1__GetFileInformation (92)
/* complex XSD type 'ns1:GetFileInformation': */
class SOAP_CMAC _ns1__GetFileInformation {
      public:
        /// Optional element 'ns1:filename' of XSD type 'xsd:string'
        char *filename;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFileInformation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFileInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFileInformation, default initialized and not managed by a soap context
        virtual _ns1__GetFileInformation *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFileInformation); }
      public:
        /// Constructor with initializations
        _ns1__GetFileInformation()
        {
          filename = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFileInformation() { }
        /// Friend allocator used by soap_new__ns1__GetFileInformation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFileInformation * SOAP_FMAC2 soap_instantiate__ns1__GetFileInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:462 */
#ifndef SOAP_TYPE__ns1__GetFileInformationResponse
#define SOAP_TYPE__ns1__GetFileInformationResponse (93)
/* complex XSD type 'ns1:GetFileInformationResponse': */
class SOAP_CMAC _ns1__GetFileInformationResponse {
      public:
        /// Optional element 'ns1:GetFileInformationResult' of XSD type 'xsd:boolean'
        bool *GetFileInformationResult;
        /// Optional element 'ns1:filesize' of XSD type 'xsd:int'
        int *filesize;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFileInformationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetFileInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFileInformationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFileInformationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetFileInformationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFileInformationResponse()
        {
          GetFileInformationResult = (bool *)0;
          filesize = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetFileInformationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFileInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFileInformationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFileInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:465 */
#ifndef SOAP_TYPE__ns1__GetConfig
#define SOAP_TYPE__ns1__GetConfig (94)
/* complex XSD type 'ns1:GetConfig': */
class SOAP_CMAC _ns1__GetConfig {
      public:
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConfig
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConfig; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConfig, default initialized and not managed by a soap context
        virtual _ns1__GetConfig *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConfig); }
      public:
        /// Constructor with initializations
        _ns1__GetConfig()
        {
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConfig() { }
        /// Friend allocator used by soap_new__ns1__GetConfig(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConfig * SOAP_FMAC2 soap_instantiate__ns1__GetConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:468 */
#ifndef SOAP_TYPE__ns1__GetConfigResponse
#define SOAP_TYPE__ns1__GetConfigResponse (95)
/* complex XSD type 'ns1:GetConfigResponse': */
class SOAP_CMAC _ns1__GetConfigResponse {
      public:
        /// Optional element 'ns1:GetConfigResult' of XSD type 'xsd:boolean'
        bool *GetConfigResult;
        /// Optional element 'ns1:currentFileID' of XSD type 'xsd:int'
        int *currentFileID;
        /// Optional element 'ns1:currentChecksum' of XSD type 'xsd:int'
        int *currentChecksum;
        /// Optional element 'ns1:pendingfileID' of XSD type 'xsd:int'
        int *pendingfileID;
        /// Optional element 'ns1:pendingChecksum' of XSD type 'xsd:int'
        int *pendingChecksum;
        /// Optional element 'ns1:par' of XSD type 'xsd:double'
        double *par;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConfigResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConfigResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConfigResponse, default initialized and not managed by a soap context
        virtual _ns1__GetConfigResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConfigResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetConfigResponse()
        {
          GetConfigResult = (bool *)0;
          currentFileID = (int *)0;
          currentChecksum = (int *)0;
          pendingfileID = (int *)0;
          pendingChecksum = (int *)0;
          par = (double *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConfigResponse() { }
        /// Friend allocator used by soap_new__ns1__GetConfigResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConfigResponse * SOAP_FMAC2 soap_instantiate__ns1__GetConfigResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:471 */
#ifndef SOAP_TYPE__ns1__GetConfigEx
#define SOAP_TYPE__ns1__GetConfigEx (96)
/* complex XSD type 'ns1:GetConfigEx': */
class SOAP_CMAC _ns1__GetConfigEx {
      public:
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConfigEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConfigEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConfigEx, default initialized and not managed by a soap context
        virtual _ns1__GetConfigEx *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConfigEx); }
      public:
        /// Constructor with initializations
        _ns1__GetConfigEx()
        {
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConfigEx() { }
        /// Friend allocator used by soap_new__ns1__GetConfigEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConfigEx * SOAP_FMAC2 soap_instantiate__ns1__GetConfigEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:474 */
#ifndef SOAP_TYPE__ns1__GetConfigExResponse
#define SOAP_TYPE__ns1__GetConfigExResponse (97)
/* complex XSD type 'ns1:GetConfigExResponse': */
class SOAP_CMAC _ns1__GetConfigExResponse {
      public:
        /// Optional element 'ns1:GetConfigExResult' of XSD type 'xsd:boolean'
        bool *GetConfigExResult;
        /// Optional element 'ns1:currentFileID' of XSD type 'xsd:int'
        int *currentFileID;
        /// Optional element 'ns1:currentChecksum' of XSD type 'xsd:int'
        int *currentChecksum;
        /// Optional element 'ns1:pendingfileID' of XSD type 'xsd:int'
        int *pendingfileID;
        /// Optional element 'ns1:pendingChecksum' of XSD type 'xsd:int'
        int *pendingChecksum;
        /// Optional element 'ns1:par' of XSD type 'xsd:double'
        double *par;
        /// Optional element 'ns1:parameters' of XSD type 'ns2:ArrayOfKeyValueOfstringstring'
        ns2__ArrayOfKeyValueOfstringstring *parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetConfigExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetConfigExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetConfigExResponse, default initialized and not managed by a soap context
        virtual _ns1__GetConfigExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetConfigExResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetConfigExResponse()
        {
          GetConfigExResult = (bool *)0;
          currentFileID = (int *)0;
          currentChecksum = (int *)0;
          pendingfileID = (int *)0;
          pendingChecksum = (int *)0;
          par = (double *)0;
          parameters = (ns2__ArrayOfKeyValueOfstringstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetConfigExResponse() { }
        /// Friend allocator used by soap_new__ns1__GetConfigExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetConfigExResponse * SOAP_FMAC2 soap_instantiate__ns1__GetConfigExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:477 */
#ifndef SOAP_TYPE__ns1__GetEventXMLFile
#define SOAP_TYPE__ns1__GetEventXMLFile (98)
/* complex XSD type 'ns1:GetEventXMLFile': */
class SOAP_CMAC _ns1__GetEventXMLFile {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventXMLFile
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventXMLFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventXMLFile, default initialized and not managed by a soap context
        virtual _ns1__GetEventXMLFile *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventXMLFile); }
      public:
        /// Constructor with initializations
        _ns1__GetEventXMLFile()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventXMLFile() { }
        /// Friend allocator used by soap_new__ns1__GetEventXMLFile(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventXMLFile * SOAP_FMAC2 soap_instantiate__ns1__GetEventXMLFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:480 */
#ifndef SOAP_TYPE__ns1__GetEventXMLFileResponse
#define SOAP_TYPE__ns1__GetEventXMLFileResponse (99)
/* complex XSD type 'ns1:GetEventXMLFileResponse': */
class SOAP_CMAC _ns1__GetEventXMLFileResponse {
      public:
        /// Optional element 'ns1:GetEventXMLFileResult' of XSD type 'xsd:boolean'
        bool *GetEventXMLFileResult;
        /// Optional element 'ns1:fileID' of XSD type 'xsd:int'
        int *fileID;
        /// Optional element 'ns1:checksum' of XSD type 'xsd:int'
        int *checksum;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventXMLFileResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventXMLFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventXMLFileResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEventXMLFileResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventXMLFileResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEventXMLFileResponse()
        {
          GetEventXMLFileResult = (bool *)0;
          fileID = (int *)0;
          checksum = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventXMLFileResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEventXMLFileResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventXMLFileResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEventXMLFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:483 */
#ifndef SOAP_TYPE__ns1__InEventTrigger
#define SOAP_TYPE__ns1__InEventTrigger (100)
/* complex XSD type 'ns1:InEventTrigger': */
class SOAP_CMAC _ns1__InEventTrigger {
      public:
        /// Optional element 'ns1:eventID' of XSD type 'xsd:int'
        int *eventID;
        /// Optional element 'ns1:jackpotAmount' of XSD type 'xsd:long'
        LONG64 *jackpotAmount;
        /// Optional element 'ns1:initialTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *initialTimeStamp;
        /// Optional element 'ns1:currentTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *currentTimeStamp;
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:lastTriggeredEventId' of XSD type 'xsd:int'
        int *lastTriggeredEventId;
        /// Optional element 'ns1:initialCoinIn' of XSD type 'xsd:long'
        LONG64 *initialCoinIn;
        /// Optional element 'ns1:initialCoinOut' of XSD type 'xsd:long'
        LONG64 *initialCoinOut;
        /// Optional element 'ns1:initialJackpotHandpay' of XSD type 'xsd:long'
        LONG64 *initialJackpotHandpay;
        /// Optional element 'ns1:initialExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingMachinePayout;
        /// Optional element 'ns1:initialExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingAttendantPayout;
        /// Optional element 'ns1:initialAttendantPayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *initialAttendantPayProgressivePayout;
        /// Optional element 'ns1:initialMachinePayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *initialMachinePayProgressivePayout;
        /// Optional element 'ns1:currentCoinIn' of XSD type 'xsd:long'
        LONG64 *currentCoinIn;
        /// Optional element 'ns1:currentCoinOut' of XSD type 'xsd:long'
        LONG64 *currentCoinOut;
        /// Optional element 'ns1:currentJackpotHandpay' of XSD type 'xsd:long'
        LONG64 *currentJackpotHandpay;
        /// Optional element 'ns1:currentExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingMachinePayout;
        /// Optional element 'ns1:currentExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingAttendantPayout;
        /// Optional element 'ns1:currentAttendantPayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *currentAttendantPayProgressivePayout;
        /// Optional element 'ns1:currentMachinePayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *currentMachinePayProgressivePayout;
        /// Optional element 'ns1:nonTriggeredEventList' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *nonTriggeredEventList;
        /// Optional element 'ns1:nonTriggeredEventsCount' of XSD type 'xsd:int'
        int *nonTriggeredEventsCount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InEventTrigger
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InEventTrigger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InEventTrigger, default initialized and not managed by a soap context
        virtual _ns1__InEventTrigger *soap_alloc(void) const { return SOAP_NEW(_ns1__InEventTrigger); }
      public:
        /// Constructor with initializations
        _ns1__InEventTrigger()
        {
          eventID = (int *)0;
          jackpotAmount = (LONG64 *)0;
          initialTimeStamp = (xsd__base64Binary *)0;
          currentTimeStamp = (xsd__base64Binary *)0;
          slotMastId = (int *)0;
          OCR = (char *)0;
          lastTriggeredEventId = (int *)0;
          initialCoinIn = (LONG64 *)0;
          initialCoinOut = (LONG64 *)0;
          initialJackpotHandpay = (LONG64 *)0;
          initialExternalBonusingMachinePayout = (LONG64 *)0;
          initialExternalBonusingAttendantPayout = (LONG64 *)0;
          initialAttendantPayProgressivePayout = (LONG64 *)0;
          initialMachinePayProgressivePayout = (LONG64 *)0;
          currentCoinIn = (LONG64 *)0;
          currentCoinOut = (LONG64 *)0;
          currentJackpotHandpay = (LONG64 *)0;
          currentExternalBonusingMachinePayout = (LONG64 *)0;
          currentExternalBonusingAttendantPayout = (LONG64 *)0;
          currentAttendantPayProgressivePayout = (LONG64 *)0;
          currentMachinePayProgressivePayout = (LONG64 *)0;
          nonTriggeredEventList = (xsd__base64Binary *)0;
          nonTriggeredEventsCount = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InEventTrigger() { }
        /// Friend allocator used by soap_new__ns1__InEventTrigger(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InEventTrigger * SOAP_FMAC2 soap_instantiate__ns1__InEventTrigger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:486 */
#ifndef SOAP_TYPE__ns1__InEventTriggerResponse
#define SOAP_TYPE__ns1__InEventTriggerResponse (101)
/* complex XSD type 'ns1:InEventTriggerResponse': */
class SOAP_CMAC _ns1__InEventTriggerResponse {
      public:
        /// Optional element 'ns1:InEventTriggerResult' of XSD type 'xsd:boolean'
        bool *InEventTriggerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InEventTriggerResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InEventTriggerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InEventTriggerResponse, default initialized and not managed by a soap context
        virtual _ns1__InEventTriggerResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InEventTriggerResponse); }
      public:
        /// Constructor with initializations
        _ns1__InEventTriggerResponse()
        {
          InEventTriggerResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InEventTriggerResponse() { }
        /// Friend allocator used by soap_new__ns1__InEventTriggerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InEventTriggerResponse * SOAP_FMAC2 soap_instantiate__ns1__InEventTriggerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:489 */
#ifndef SOAP_TYPE__ns1__InTriggeredEventTrigger
#define SOAP_TYPE__ns1__InTriggeredEventTrigger (102)
/* complex XSD type 'ns1:InTriggeredEventTrigger': */
class SOAP_CMAC _ns1__InTriggeredEventTrigger {
      public:
        /// Optional element 'ns1:eventID' of XSD type 'xsd:int'
        int *eventID;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:pointsEarned' of XSD type 'xsd:int'
        int *pointsEarned;
        /// Optional element 'ns1:jackpotAmount' of XSD type 'xsd:long'
        LONG64 *jackpotAmount;
        /// Optional element 'ns1:initialTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *initialTimeStamp;
        /// Optional element 'ns1:currentTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *currentTimeStamp;
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:initialCoinIn' of XSD type 'xsd:long'
        LONG64 *initialCoinIn;
        /// Optional element 'ns1:initialCoinOut' of XSD type 'xsd:long'
        LONG64 *initialCoinOut;
        /// Optional element 'ns1:initialJackpotHandpay' of XSD type 'xsd:long'
        LONG64 *initialJackpotHandpay;
        /// Optional element 'ns1:initialExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingMachinePayout;
        /// Optional element 'ns1:initialExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingAttendantPayout;
        /// Optional element 'ns1:initialAttendantPayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *initialAttendantPayProgressivePayout;
        /// Optional element 'ns1:initialMachinePayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *initialMachinePayProgressivePayout;
        /// Optional element 'ns1:currentCoinIn' of XSD type 'xsd:long'
        LONG64 *currentCoinIn;
        /// Optional element 'ns1:currentCoinOut' of XSD type 'xsd:long'
        LONG64 *currentCoinOut;
        /// Optional element 'ns1:currentJackpotHandpay' of XSD type 'xsd:long'
        LONG64 *currentJackpotHandpay;
        /// Optional element 'ns1:currentExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingMachinePayout;
        /// Optional element 'ns1:currentExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingAttendantPayout;
        /// Optional element 'ns1:currentAttendantPayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *currentAttendantPayProgressivePayout;
        /// Optional element 'ns1:currentMachinePayProgressivePayout' of XSD type 'xsd:long'
        LONG64 *currentMachinePayProgressivePayout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InTriggeredEventTrigger
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InTriggeredEventTrigger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InTriggeredEventTrigger, default initialized and not managed by a soap context
        virtual _ns1__InTriggeredEventTrigger *soap_alloc(void) const { return SOAP_NEW(_ns1__InTriggeredEventTrigger); }
      public:
        /// Constructor with initializations
        _ns1__InTriggeredEventTrigger()
        {
          eventID = (int *)0;
          triggeredEventID = (int *)0;
          pointsEarned = (int *)0;
          jackpotAmount = (LONG64 *)0;
          initialTimeStamp = (xsd__base64Binary *)0;
          currentTimeStamp = (xsd__base64Binary *)0;
          slotMastId = (int *)0;
          OCR = (char *)0;
          initialCoinIn = (LONG64 *)0;
          initialCoinOut = (LONG64 *)0;
          initialJackpotHandpay = (LONG64 *)0;
          initialExternalBonusingMachinePayout = (LONG64 *)0;
          initialExternalBonusingAttendantPayout = (LONG64 *)0;
          initialAttendantPayProgressivePayout = (LONG64 *)0;
          initialMachinePayProgressivePayout = (LONG64 *)0;
          currentCoinIn = (LONG64 *)0;
          currentCoinOut = (LONG64 *)0;
          currentJackpotHandpay = (LONG64 *)0;
          currentExternalBonusingMachinePayout = (LONG64 *)0;
          currentExternalBonusingAttendantPayout = (LONG64 *)0;
          currentAttendantPayProgressivePayout = (LONG64 *)0;
          currentMachinePayProgressivePayout = (LONG64 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InTriggeredEventTrigger() { }
        /// Friend allocator used by soap_new__ns1__InTriggeredEventTrigger(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InTriggeredEventTrigger * SOAP_FMAC2 soap_instantiate__ns1__InTriggeredEventTrigger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:492 */
#ifndef SOAP_TYPE__ns1__InTriggeredEventTriggerResponse
#define SOAP_TYPE__ns1__InTriggeredEventTriggerResponse (103)
/* complex XSD type 'ns1:InTriggeredEventTriggerResponse': */
class SOAP_CMAC _ns1__InTriggeredEventTriggerResponse {
      public:
        /// Optional element 'ns1:InTriggeredEventTriggerResult' of XSD type 'xsd:boolean'
        bool *InTriggeredEventTriggerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__InTriggeredEventTriggerResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__InTriggeredEventTriggerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__InTriggeredEventTriggerResponse, default initialized and not managed by a soap context
        virtual _ns1__InTriggeredEventTriggerResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__InTriggeredEventTriggerResponse); }
      public:
        /// Constructor with initializations
        _ns1__InTriggeredEventTriggerResponse()
        {
          InTriggeredEventTriggerResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__InTriggeredEventTriggerResponse() { }
        /// Friend allocator used by soap_new__ns1__InTriggeredEventTriggerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__InTriggeredEventTriggerResponse * SOAP_FMAC2 soap_instantiate__ns1__InTriggeredEventTriggerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:495 */
#ifndef SOAP_TYPE__ns1__ReportEventMeterDeltas
#define SOAP_TYPE__ns1__ReportEventMeterDeltas (104)
/* complex XSD type 'ns1:ReportEventMeterDeltas': */
class SOAP_CMAC _ns1__ReportEventMeterDeltas {
      public:
        /// Optional element 'ns1:eventID' of XSD type 'xsd:int'
        int *eventID;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:jackpotAmount' of XSD type 'xsd:long'
        LONG64 *jackpotAmount;
        /// Optional element 'ns1:timeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *timeStamp;
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:splashdownPoints' of XSD type 'xsd:long'
        LONG64 *splashdownPoints;
        /// Optional element 'ns1:coinInDelta' of XSD type 'xsd:long'
        LONG64 *coinInDelta;
        /// Optional element 'ns1:coinOutDelta' of XSD type 'xsd:long'
        LONG64 *coinOutDelta;
        /// Optional element 'ns1:jackpotHandpayDelta' of XSD type 'xsd:long'
        LONG64 *jackpotHandpayDelta;
        /// Optional element 'ns1:externalBonusingMachinePayoutDelta' of XSD type 'xsd:long'
        LONG64 *externalBonusingMachinePayoutDelta;
        /// Optional element 'ns1:externalBonusingAttendantPayoutDelta' of XSD type 'xsd:long'
        LONG64 *externalBonusingAttendantPayoutDelta;
        /// Optional element 'ns1:attendantPayProgressivePayoutDelta' of XSD type 'xsd:long'
        LONG64 *attendantPayProgressivePayoutDelta;
        /// Optional element 'ns1:machinePayProgressivePayoutDelta' of XSD type 'xsd:long'
        LONG64 *machinePayProgressivePayoutDelta;
        /// Optional element 'ns1:millisecondsPlayedDelta' of XSD type 'xsd:long'
        LONG64 *millisecondsPlayedDelta;
        /// Optional element 'ns1:jackpotType' of XSD type 'xsd:int'
        int *jackpotType;
        /// Optional element 'ns1:denomination' of XSD type 'xsd:double'
        double *denomination;
        /// Optional element 'ns1:par' of XSD type 'xsd:double'
        double *par;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportEventMeterDeltas
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportEventMeterDeltas; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportEventMeterDeltas, default initialized and not managed by a soap context
        virtual _ns1__ReportEventMeterDeltas *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportEventMeterDeltas); }
      public:
        /// Constructor with initializations
        _ns1__ReportEventMeterDeltas()
        {
          eventID = (int *)0;
          triggeredEventID = (int *)0;
          jackpotAmount = (LONG64 *)0;
          timeStamp = (xsd__base64Binary *)0;
          slotMastId = (int *)0;
          OCR = (char *)0;
          splashdownPoints = (LONG64 *)0;
          coinInDelta = (LONG64 *)0;
          coinOutDelta = (LONG64 *)0;
          jackpotHandpayDelta = (LONG64 *)0;
          externalBonusingMachinePayoutDelta = (LONG64 *)0;
          externalBonusingAttendantPayoutDelta = (LONG64 *)0;
          attendantPayProgressivePayoutDelta = (LONG64 *)0;
          machinePayProgressivePayoutDelta = (LONG64 *)0;
          millisecondsPlayedDelta = (LONG64 *)0;
          jackpotType = (int *)0;
          denomination = (double *)0;
          par = (double *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportEventMeterDeltas() { }
        /// Friend allocator used by soap_new__ns1__ReportEventMeterDeltas(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportEventMeterDeltas * SOAP_FMAC2 soap_instantiate__ns1__ReportEventMeterDeltas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:498 */
#ifndef SOAP_TYPE__ns1__ReportEventMeterDeltasResponse
#define SOAP_TYPE__ns1__ReportEventMeterDeltasResponse (105)
/* complex XSD type 'ns1:ReportEventMeterDeltasResponse': */
class SOAP_CMAC _ns1__ReportEventMeterDeltasResponse {
      public:
        /// Optional element 'ns1:ReportEventMeterDeltasResult' of XSD type 'xsd:boolean'
        bool *ReportEventMeterDeltasResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportEventMeterDeltasResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportEventMeterDeltasResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportEventMeterDeltasResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportEventMeterDeltasResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportEventMeterDeltasResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportEventMeterDeltasResponse()
        {
          ReportEventMeterDeltasResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportEventMeterDeltasResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportEventMeterDeltasResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportEventMeterDeltasResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportEventMeterDeltasResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:501 */
#ifndef SOAP_TYPE__ns1__ReportGameStart
#define SOAP_TYPE__ns1__ReportGameStart (106)
/* complex XSD type 'ns1:ReportGameStart': */
class SOAP_CMAC _ns1__ReportGameStart {
      public:
        /// Optional element 'ns1:CoinInMeterCents' of XSD type 'xsd:long'
        LONG64 *CoinInMeterCents;
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:timeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *timeStamp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportGameStart
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportGameStart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportGameStart, default initialized and not managed by a soap context
        virtual _ns1__ReportGameStart *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportGameStart); }
      public:
        /// Constructor with initializations
        _ns1__ReportGameStart()
        {
          CoinInMeterCents = (LONG64 *)0;
          slotMastId = (int *)0;
          timeStamp = (xsd__base64Binary *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportGameStart() { }
        /// Friend allocator used by soap_new__ns1__ReportGameStart(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportGameStart * SOAP_FMAC2 soap_instantiate__ns1__ReportGameStart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:504 */
#ifndef SOAP_TYPE__ns1__ReportGameStartResponse
#define SOAP_TYPE__ns1__ReportGameStartResponse (107)
/* complex XSD type 'ns1:ReportGameStartResponse': */
class SOAP_CMAC _ns1__ReportGameStartResponse {
      public:
        /// Optional element 'ns1:ReportGameStartResult' of XSD type 'xsd:boolean'
        bool *ReportGameStartResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportGameStartResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportGameStartResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportGameStartResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportGameStartResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportGameStartResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportGameStartResponse()
        {
          ReportGameStartResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportGameStartResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportGameStartResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportGameStartResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportGameStartResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:507 */
#ifndef SOAP_TYPE__ns1__AcknowledgeExternalPaid
#define SOAP_TYPE__ns1__AcknowledgeExternalPaid (108)
/* complex XSD type 'ns1:AcknowledgeExternalPaid': */
class SOAP_CMAC _ns1__AcknowledgeExternalPaid {
      public:
        /// Optional element 'ns1:awardID' of XSD type 'xsd:int'
        int *awardID;
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OCR' of XSD type 'xsd:string'
        char *OCR;
        /// Optional element 'ns1:amountPaid' of XSD type 'xsd:int'
        int *amountPaid;
        /// Optional element 'ns1:awardResult' of XSD type 'xsd:int'
        int *awardResult;
        /// Optional element 'ns1:awardType' of XSD type 'xsd:int'
        int *awardType;
        /// Optional element 'ns1:transactionID' of XSD type 'xsd:string'
        char *transactionID;
        /// Optional element 'ns1:coinIn' of XSD type 'xsd:long'
        LONG64 *coinIn;
        /// Optional element 'ns1:coinOut' of XSD type 'xsd:long'
        LONG64 *coinOut;
        /// Optional element 'ns1:progCoinIn' of XSD type 'xsd:long'
        LONG64 *progCoinIn;
        /// Optional element 'ns1:initialExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingMachinePayout;
        /// Optional element 'ns1:initialExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *initialExternalBonusingAttendantPayout;
        /// Optional element 'ns1:currentExternalBonusingMachinePayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingMachinePayout;
        /// Optional element 'ns1:currentExternalBonusingAttendantPayout' of XSD type 'xsd:long'
        LONG64 *currentExternalBonusingAttendantPayout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AcknowledgeExternalPaid
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AcknowledgeExternalPaid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AcknowledgeExternalPaid, default initialized and not managed by a soap context
        virtual _ns1__AcknowledgeExternalPaid *soap_alloc(void) const { return SOAP_NEW(_ns1__AcknowledgeExternalPaid); }
      public:
        /// Constructor with initializations
        _ns1__AcknowledgeExternalPaid()
        {
          awardID = (int *)0;
          slotMastId = (int *)0;
          OCR = (char *)0;
          amountPaid = (int *)0;
          awardResult = (int *)0;
          awardType = (int *)0;
          transactionID = (char *)0;
          coinIn = (LONG64 *)0;
          coinOut = (LONG64 *)0;
          progCoinIn = (LONG64 *)0;
          initialExternalBonusingMachinePayout = (LONG64 *)0;
          initialExternalBonusingAttendantPayout = (LONG64 *)0;
          currentExternalBonusingMachinePayout = (LONG64 *)0;
          currentExternalBonusingAttendantPayout = (LONG64 *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AcknowledgeExternalPaid() { }
        /// Friend allocator used by soap_new__ns1__AcknowledgeExternalPaid(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AcknowledgeExternalPaid * SOAP_FMAC2 soap_instantiate__ns1__AcknowledgeExternalPaid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:510 */
#ifndef SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse
#define SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse (109)
/* complex XSD type 'ns1:AcknowledgeExternalPaidResponse': */
class SOAP_CMAC _ns1__AcknowledgeExternalPaidResponse {
      public:
        /// Optional element 'ns1:AcknowledgeExternalPaidResult' of XSD type 'xsd:boolean'
        bool *AcknowledgeExternalPaidResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AcknowledgeExternalPaidResponse, default initialized and not managed by a soap context
        virtual _ns1__AcknowledgeExternalPaidResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__AcknowledgeExternalPaidResponse); }
      public:
        /// Constructor with initializations
        _ns1__AcknowledgeExternalPaidResponse()
        {
          AcknowledgeExternalPaidResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__AcknowledgeExternalPaidResponse() { }
        /// Friend allocator used by soap_new__ns1__AcknowledgeExternalPaidResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AcknowledgeExternalPaidResponse * SOAP_FMAC2 soap_instantiate__ns1__AcknowledgeExternalPaidResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:513 */
#ifndef SOAP_TYPE__ns1__ReportStatus
#define SOAP_TYPE__ns1__ReportStatus (110)
/* complex XSD type 'ns1:ReportStatus': */
class SOAP_CMAC _ns1__ReportStatus {
      public:
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:status' of XSD type 'xsd:string'
        char *status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportStatus, default initialized and not managed by a soap context
        virtual _ns1__ReportStatus *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportStatus); }
      public:
        /// Constructor with initializations
        _ns1__ReportStatus()
        {
          slotMastId = (int *)0;
          status = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportStatus() { }
        /// Friend allocator used by soap_new__ns1__ReportStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportStatus * SOAP_FMAC2 soap_instantiate__ns1__ReportStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:516 */
#ifndef SOAP_TYPE__ns1__ReportStatusResponse
#define SOAP_TYPE__ns1__ReportStatusResponse (111)
/* complex XSD type 'ns1:ReportStatusResponse': */
class SOAP_CMAC _ns1__ReportStatusResponse {
      public:
        /// Optional element 'ns1:ReportStatusResult' of XSD type 'xsd:boolean'
        bool *ReportStatusResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportStatusResponse()
        {
          ReportStatusResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:519 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation
#define SOAP_TYPE__ns1__ReportSentinelInformation (112)
/* complex XSD type 'ns1:ReportSentinelInformation': */
class SOAP_CMAC _ns1__ReportSentinelInformation {
      public:
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OSVersion' of XSD type 'xsd:string'
        char *OSVersion;
        /// Optional element 'ns1:EXEVersion' of XSD type 'xsd:string'
        char *EXEVersion;
        /// Optional element 'ns1:SkinName' of XSD type 'xsd:string'
        char *SkinName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformation, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformation *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformation); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformation()
        {
          slotMastId = (int *)0;
          OSVersion = (char *)0;
          EXEVersion = (char *)0;
          SkinName = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformation() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformation * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:522 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationResponse (113)
/* complex XSD type 'ns1:ReportSentinelInformationResponse': */
class SOAP_CMAC _ns1__ReportSentinelInformationResponse {
      public:
        /// Optional element 'ns1:ReportSentinelInformationResult' of XSD type 'xsd:boolean'
        bool *ReportSentinelInformationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformationResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformationResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformationResponse()
        {
          ReportSentinelInformationResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformationResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformationResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:525 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation
#define SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation (114)
/* complex XSD type 'ns1:ReportSentinelInformationWithOrientation': */
class SOAP_CMAC _ns1__ReportSentinelInformationWithOrientation {
      public:
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OSVersion' of XSD type 'xsd:string'
        char *OSVersion;
        /// Optional element 'ns1:EXEVersion' of XSD type 'xsd:string'
        char *EXEVersion;
        /// Optional element 'ns1:SkinName' of XSD type 'xsd:string'
        char *SkinName;
        /// Optional element 'ns1:DisplayOrientation' of XSD type 'xsd:unsignedByte'
        unsigned char *DisplayOrientation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformationWithOrientation, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformationWithOrientation *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformationWithOrientation); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformationWithOrientation()
        {
          slotMastId = (int *)0;
          OSVersion = (char *)0;
          EXEVersion = (char *)0;
          SkinName = (char *)0;
          DisplayOrientation = (unsigned char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformationWithOrientation() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformationWithOrientation(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformationWithOrientation * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformationWithOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:528 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse (115)
/* complex XSD type 'ns1:ReportSentinelInformationWithOrientationResponse': */
class SOAP_CMAC _ns1__ReportSentinelInformationWithOrientationResponse {
      public:
        /// Optional element 'ns1:ReportSentinelInformationWithOrientationResult' of XSD type 'xsd:boolean'
        bool *ReportSentinelInformationWithOrientationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformationWithOrientationResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformationWithOrientationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformationWithOrientationResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformationWithOrientationResponse()
        {
          ReportSentinelInformationWithOrientationResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformationWithOrientationResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformationWithOrientationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformationWithOrientationResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformationWithOrientationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:531 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationEx
#define SOAP_TYPE__ns1__ReportSentinelInformationEx (116)
/* complex XSD type 'ns1:ReportSentinelInformationEx': */
class SOAP_CMAC _ns1__ReportSentinelInformationEx {
      public:
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:parameters' of XSD type 'ns2:ArrayOfKeyValueOfstringstring'
        ns2__ArrayOfKeyValueOfstringstring *parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformationEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformationEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformationEx, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformationEx *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformationEx); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformationEx()
        {
          slotMastId = (int *)0;
          parameters = (ns2__ArrayOfKeyValueOfstringstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformationEx() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformationEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformationEx * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformationEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:534 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationExResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationExResponse (117)
/* complex XSD type 'ns1:ReportSentinelInformationExResponse': */
class SOAP_CMAC _ns1__ReportSentinelInformationExResponse {
      public:
        /// Optional element 'ns1:ReportSentinelInformationExResult' of XSD type 'xsd:boolean'
        bool *ReportSentinelInformationExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformationExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformationExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformationExResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformationExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformationExResponse); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformationExResponse()
        {
          ReportSentinelInformationExResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformationExResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformationExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformationExResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformationExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:537 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation25
#define SOAP_TYPE__ns1__ReportSentinelInformation25 (118)
/* complex XSD type 'ns1:ReportSentinelInformation25': */
class SOAP_CMAC _ns1__ReportSentinelInformation25 {
      public:
        /// Optional element 'ns1:slotMastId' of XSD type 'xsd:int'
        int *slotMastId;
        /// Optional element 'ns1:OSVersion' of XSD type 'xsd:string'
        char *OSVersion;
        /// Optional element 'ns1:EXEVersion' of XSD type 'xsd:string'
        char *EXEVersion;
        /// Optional element 'ns1:SkinName' of XSD type 'xsd:string'
        char *SkinName;
        /// Optional element 'ns1:ExternalBonusType' of XSD type 'xsd:int'
        int *ExternalBonusType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformation25
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformation25; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformation25, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformation25 *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformation25); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformation25()
        {
          slotMastId = (int *)0;
          OSVersion = (char *)0;
          EXEVersion = (char *)0;
          SkinName = (char *)0;
          ExternalBonusType = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformation25() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformation25(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformation25 * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformation25(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:540 */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation25Response
#define SOAP_TYPE__ns1__ReportSentinelInformation25Response (119)
/* complex XSD type 'ns1:ReportSentinelInformation25Response': */
class SOAP_CMAC _ns1__ReportSentinelInformation25Response {
      public:
        /// Optional element 'ns1:ReportSentinelInformation25Result' of XSD type 'xsd:boolean'
        bool *ReportSentinelInformation25Result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportSentinelInformation25Response
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ReportSentinelInformation25Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportSentinelInformation25Response, default initialized and not managed by a soap context
        virtual _ns1__ReportSentinelInformation25Response *soap_alloc(void) const { return SOAP_NEW(_ns1__ReportSentinelInformation25Response); }
      public:
        /// Constructor with initializations
        _ns1__ReportSentinelInformation25Response()
        {
          ReportSentinelInformation25Result = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ReportSentinelInformation25Response() { }
        /// Friend allocator used by soap_new__ns1__ReportSentinelInformation25Response(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportSentinelInformation25Response * SOAP_FMAC2 soap_instantiate__ns1__ReportSentinelInformation25Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:543 */
#ifndef SOAP_TYPE__ns1__GetThirdPartyBlob
#define SOAP_TYPE__ns1__GetThirdPartyBlob (120)
/* complex XSD type 'ns1:GetThirdPartyBlob': */
class SOAP_CMAC _ns1__GetThirdPartyBlob {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetThirdPartyBlob
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetThirdPartyBlob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetThirdPartyBlob, default initialized and not managed by a soap context
        virtual _ns1__GetThirdPartyBlob *soap_alloc(void) const { return SOAP_NEW(_ns1__GetThirdPartyBlob); }
      public:
        /// Constructor with initializations
        _ns1__GetThirdPartyBlob()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetThirdPartyBlob() { }
        /// Friend allocator used by soap_new__ns1__GetThirdPartyBlob(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetThirdPartyBlob * SOAP_FMAC2 soap_instantiate__ns1__GetThirdPartyBlob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:546 */
#ifndef SOAP_TYPE__ns1__GetThirdPartyBlobResponse
#define SOAP_TYPE__ns1__GetThirdPartyBlobResponse (121)
/* complex XSD type 'ns1:GetThirdPartyBlobResponse': */
class SOAP_CMAC _ns1__GetThirdPartyBlobResponse {
      public:
        /// Optional element 'ns1:GetThirdPartyBlobResult' of XSD type 'xsd:boolean'
        bool *GetThirdPartyBlobResult;
        /// Optional element 'ns1:sessionId' of XSD type 'xsd:string'
        char *sessionId;
        /// Optional element 'ns1:vendorId' of XSD type 'xsd:int'
        int *vendorId;
        /// Optional element 'ns1:apiNotificationType' of XSD type 'xsd:int'
        int *apiNotificationType;
        /// Optional element 'ns1:playerType' of XSD type 'xsd:int'
        int *playerType;
        /// Optional element 'ns1:blob' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *blob;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetThirdPartyBlobResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetThirdPartyBlobResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetThirdPartyBlobResponse, default initialized and not managed by a soap context
        virtual _ns1__GetThirdPartyBlobResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetThirdPartyBlobResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetThirdPartyBlobResponse()
        {
          GetThirdPartyBlobResult = (bool *)0;
          sessionId = (char *)0;
          vendorId = (int *)0;
          apiNotificationType = (int *)0;
          playerType = (int *)0;
          blob = (xsd__base64Binary *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetThirdPartyBlobResponse() { }
        /// Friend allocator used by soap_new__ns1__GetThirdPartyBlobResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetThirdPartyBlobResponse * SOAP_FMAC2 soap_instantiate__ns1__GetThirdPartyBlobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:549 */
#ifndef SOAP_TYPE__ns1__SendBlobToThirdParty
#define SOAP_TYPE__ns1__SendBlobToThirdParty (122)
/* complex XSD type 'ns1:SendBlobToThirdParty': */
class SOAP_CMAC _ns1__SendBlobToThirdParty {
      public:
        /// Optional element 'ns1:sessionId' of XSD type 'xsd:string'
        char *sessionId;
        /// Optional element 'ns1:slotmastId' of XSD type 'xsd:int'
        int *slotmastId;
        /// Optional element 'ns1:blob' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *blob;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendBlobToThirdParty
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendBlobToThirdParty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendBlobToThirdParty, default initialized and not managed by a soap context
        virtual _ns1__SendBlobToThirdParty *soap_alloc(void) const { return SOAP_NEW(_ns1__SendBlobToThirdParty); }
      public:
        /// Constructor with initializations
        _ns1__SendBlobToThirdParty()
        {
          sessionId = (char *)0;
          slotmastId = (int *)0;
          blob = (xsd__base64Binary *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendBlobToThirdParty() { }
        /// Friend allocator used by soap_new__ns1__SendBlobToThirdParty(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendBlobToThirdParty * SOAP_FMAC2 soap_instantiate__ns1__SendBlobToThirdParty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:552 */
#ifndef SOAP_TYPE__ns1__SendBlobToThirdPartyResponse
#define SOAP_TYPE__ns1__SendBlobToThirdPartyResponse (123)
/* complex XSD type 'ns1:SendBlobToThirdPartyResponse': */
class SOAP_CMAC _ns1__SendBlobToThirdPartyResponse {
      public:
        /// Optional element 'ns1:SendBlobToThirdPartyResult' of XSD type 'xsd:boolean'
        bool *SendBlobToThirdPartyResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SendBlobToThirdPartyResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__SendBlobToThirdPartyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SendBlobToThirdPartyResponse, default initialized and not managed by a soap context
        virtual _ns1__SendBlobToThirdPartyResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__SendBlobToThirdPartyResponse); }
      public:
        /// Constructor with initializations
        _ns1__SendBlobToThirdPartyResponse()
        {
          SendBlobToThirdPartyResult = (bool *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__SendBlobToThirdPartyResponse() { }
        /// Friend allocator used by soap_new__ns1__SendBlobToThirdPartyResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SendBlobToThirdPartyResponse * SOAP_FMAC2 soap_instantiate__ns1__SendBlobToThirdPartyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:555 */
#ifndef SOAP_TYPE__ns1__GetEventTriggerNotification
#define SOAP_TYPE__ns1__GetEventTriggerNotification (124)
/* complex XSD type 'ns1:GetEventTriggerNotification': */
class SOAP_CMAC _ns1__GetEventTriggerNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventTriggerNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventTriggerNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventTriggerNotification, default initialized and not managed by a soap context
        virtual _ns1__GetEventTriggerNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventTriggerNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetEventTriggerNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventTriggerNotification() { }
        /// Friend allocator used by soap_new__ns1__GetEventTriggerNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventTriggerNotification * SOAP_FMAC2 soap_instantiate__ns1__GetEventTriggerNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:558 */
#ifndef SOAP_TYPE__ns1__GetEventTriggerNotificationResponse
#define SOAP_TYPE__ns1__GetEventTriggerNotificationResponse (125)
/* complex XSD type 'ns1:GetEventTriggerNotificationResponse': */
class SOAP_CMAC _ns1__GetEventTriggerNotificationResponse {
      public:
        /// Optional element 'ns1:GetEventTriggerNotificationResult' of XSD type 'xsd:boolean'
        bool *GetEventTriggerNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:lastTriggeredEventId' of XSD type 'xsd:int'
        int *lastTriggeredEventId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetEventTriggerNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetEventTriggerNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetEventTriggerNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetEventTriggerNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetEventTriggerNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetEventTriggerNotificationResponse()
        {
          GetEventTriggerNotificationResult = (bool *)0;
          eventId = (int *)0;
          lastTriggeredEventId = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetEventTriggerNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetEventTriggerNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetEventTriggerNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetEventTriggerNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:561 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom (126)
/* complex XSD type 'ns1:GetCasinoChallengeTriggeredEventNotificationCustom': */
class SOAP_CMAC _ns1__GetCasinoChallengeTriggeredEventNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeTriggeredEventNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeTriggeredEventNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeTriggeredEventNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeTriggeredEventNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeTriggeredEventNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:564 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse (127)
/* complex XSD type 'ns1:GetCasinoChallengeTriggeredEventNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetCasinoChallengeTriggeredEventNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetCasinoChallengeTriggeredEventNotificationCustomResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventId' of XSD type 'xsd:int'
        int *triggeredEventId;
        /// Optional element 'ns1:initialPercentage' of XSD type 'xsd:double'
        double *initialPercentage;
        /// Optional element 'ns1:nextGoalPercentage' of XSD type 'xsd:double'
        double *nextGoalPercentage;
        /// Optional element 'ns1:showStart' of XSD type 'xsd:boolean'
        bool *showStart;
        /// Optional element 'ns1:currentGoalLevel' of XSD type 'xsd:int'
        int *currentGoalLevel;
        /// Optional element 'ns1:totalNumGoals' of XSD type 'xsd:int'
        int *totalNumGoals;
        /// Optional element 'ns1:customWelcomeScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customWelcomeScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse()
        {
          GetCasinoChallengeTriggeredEventNotificationCustomResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventId = (int *)0;
          initialPercentage = (double *)0;
          nextGoalPercentage = (double *)0;
          showStart = (bool *)0;
          currentGoalLevel = (int *)0;
          totalNumGoals = (int *)0;
          customWelcomeScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:567 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification
#define SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification (128)
/* complex XSD type 'ns1:GetCasinoChallangeIncrementNotification': */
class SOAP_CMAC _ns1__GetCasinoChallangeIncrementNotification {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallangeIncrementNotification, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallangeIncrementNotification *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallangeIncrementNotification); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallangeIncrementNotification()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallangeIncrementNotification() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallangeIncrementNotification(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallangeIncrementNotification * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallangeIncrementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:570 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse
#define SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse (129)
/* complex XSD type 'ns1:GetCasinoChallangeIncrementNotificationResponse': */
class SOAP_CMAC _ns1__GetCasinoChallangeIncrementNotificationResponse {
      public:
        /// Optional element 'ns1:GetCasinoChallangeIncrementNotificationResult' of XSD type 'xsd:boolean'
        bool *GetCasinoChallangeIncrementNotificationResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventId' of XSD type 'xsd:int'
        int *triggeredEventId;
        /// Optional element 'ns1:currentPercentage' of XSD type 'xsd:double'
        double *currentPercentage;
        /// Optional element 'ns1:nextGoalPercentage' of XSD type 'xsd:double'
        double *nextGoalPercentage;
        /// Optional element 'ns1:currentGoalLevel' of XSD type 'xsd:int'
        int *currentGoalLevel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallangeIncrementNotificationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallangeIncrementNotificationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallangeIncrementNotificationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallangeIncrementNotificationResponse()
        {
          GetCasinoChallangeIncrementNotificationResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventId = (int *)0;
          currentPercentage = (double *)0;
          nextGoalPercentage = (double *)0;
          currentGoalLevel = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallangeIncrementNotificationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallangeIncrementNotificationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallangeIncrementNotificationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallangeIncrementNotificationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:573 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom (130)
/* complex XSD type 'ns1:GetCasinoChallangeEventEndNotificationCustom': */
class SOAP_CMAC _ns1__GetCasinoChallangeEventEndNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallangeEventEndNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallangeEventEndNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallangeEventEndNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallangeEventEndNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallangeEventEndNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallangeEventEndNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:576 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse (131)
/* complex XSD type 'ns1:GetCasinoChallangeEventEndNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetCasinoChallangeEventEndNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetCasinoChallangeEventEndNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetCasinoChallangeEventEndNotificationCustomResult;
        /// Optional element 'ns1:eventId' of XSD type 'xsd:int'
        int *eventId;
        /// Optional element 'ns1:triggeredEventId' of XSD type 'xsd:int'
        int *triggeredEventId;
        /// Optional element 'ns1:totalAwardAmount' of XSD type 'xsd:double'
        double *totalAwardAmount;
        /// Optional element 'ns1:isFiveMinuteWindow' of XSD type 'xsd:boolean'
        bool *isFiveMinuteWindow;
        /// Optional element 'ns1:customEndScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customEndScreen;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallangeEventEndNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallangeEventEndNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallangeEventEndNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallangeEventEndNotificationCustomResponse()
        {
          GetCasinoChallangeEventEndNotificationCustomResult = (bool *)0;
          eventId = (int *)0;
          triggeredEventId = (int *)0;
          totalAwardAmount = (double *)0;
          isFiveMinuteWindow = (bool *)0;
          customEndScreen = (ns3__CustomMessageScreen *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallangeEventEndNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallangeEventEndNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallangeEventEndNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallangeEventEndNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:579 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom (132)
/* complex XSD type 'ns1:GetCasinoChallengeAwardNotificationCustom': */
class SOAP_CMAC _ns1__GetCasinoChallengeAwardNotificationCustom {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeAwardNotificationCustom, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeAwardNotificationCustom *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeAwardNotificationCustom); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeAwardNotificationCustom()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeAwardNotificationCustom() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeAwardNotificationCustom * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:582 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse (133)
/* complex XSD type 'ns1:GetCasinoChallengeAwardNotificationCustomResponse': */
class SOAP_CMAC _ns1__GetCasinoChallengeAwardNotificationCustomResponse {
      public:
        /// Optional element 'ns1:GetCasinoChallengeAwardNotificationCustomResult' of XSD type 'xsd:boolean'
        bool *GetCasinoChallengeAwardNotificationCustomResult;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:awardAmount' of XSD type 'xsd:double'
        double *awardAmount;
        /// Optional element 'ns1:customAwardScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customAwardScreen;
        /// Optional element 'ns1:currentGoalLevel' of XSD type 'xsd:int'
        int *currentGoalLevel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeAwardNotificationCustomResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeAwardNotificationCustomResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeAwardNotificationCustomResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeAwardNotificationCustomResponse()
        {
          GetCasinoChallengeAwardNotificationCustomResult = (bool *)0;
          triggeredEventID = (int *)0;
          awardAmount = (double *)0;
          customAwardScreen = (ns3__CustomMessageScreen *)0;
          currentGoalLevel = (int *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeAwardNotificationCustomResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeAwardNotificationCustomResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeAwardNotificationCustomResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeAwardNotificationCustomResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:585 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData (134)
/* complex XSD type 'ns1:GetCasinoChallengeAwardNotificationCustomWithMediaData': */
class SOAP_CMAC _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData {
      public:
        /// Optional element 'ns1:lastTimeStamp' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *lastTimeStamp;
        /// Optional element 'ns1:ID' of XSD type 'xsd:int'
        int *ID;
        /// Optional element 'ns1:slotmastID' of XSD type 'xsd:int'
        int *slotmastID;
        /// Optional element 'ns1:ocr' of XSD type 'xsd:string'
        char *ocr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData()
        {
          lastTimeStamp = (xsd__base64Binary *)0;
          ID = (int *)0;
          slotmastID = (int *)0;
          ocr = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:588 */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse (135)
/* complex XSD type 'ns1:GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse': */
class SOAP_CMAC _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse {
      public:
        /// Optional element 'ns1:GetCasinoChallengeAwardNotificationCustomWithMediaDataResult' of XSD type 'xsd:boolean'
        bool *GetCasinoChallengeAwardNotificationCustomWithMediaDataResult;
        /// Optional element 'ns1:triggeredEventID' of XSD type 'xsd:int'
        int *triggeredEventID;
        /// Optional element 'ns1:awardAmount' of XSD type 'xsd:double'
        double *awardAmount;
        /// Optional element 'ns1:customAwardScreen' of XSD type 'ns3:CustomMessageScreen'
        ns3__CustomMessageScreen *customAwardScreen;
        /// Optional element 'ns1:currentGoalLevel' of XSD type 'xsd:int'
        int *currentGoalLevel;
        /// Optional element 'ns1:mediaData' of XSD type 'xsd:string'
        char *mediaData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse()
        {
          GetCasinoChallengeAwardNotificationCustomWithMediaDataResult = (bool *)0;
          triggeredEventID = (int *)0;
          awardAmount = (double *)0;
          customAwardScreen = (ns3__CustomMessageScreen *)0;
          currentGoalLevel = (int *)0;
          mediaData = (char *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:591 */
#ifndef SOAP_TYPE__ns1__GetCacheMethodList
#define SOAP_TYPE__ns1__GetCacheMethodList (136)
/* complex XSD type 'ns1:GetCacheMethodList': */
class SOAP_CMAC _ns1__GetCacheMethodList {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCacheMethodList
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCacheMethodList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCacheMethodList, default initialized and not managed by a soap context
        virtual _ns1__GetCacheMethodList *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCacheMethodList); }
      public:
        /// Constructor with initializations
        _ns1__GetCacheMethodList()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCacheMethodList() { }
        /// Friend allocator used by soap_new__ns1__GetCacheMethodList(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCacheMethodList * SOAP_FMAC2 soap_instantiate__ns1__GetCacheMethodList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:594 */
#ifndef SOAP_TYPE__ns1__GetCacheMethodListResponse
#define SOAP_TYPE__ns1__GetCacheMethodListResponse (137)
/* complex XSD type 'ns1:GetCacheMethodListResponse': */
class SOAP_CMAC _ns1__GetCacheMethodListResponse {
      public:
        /// Optional element 'ns1:GetCacheMethodListResult' of XSD type 'xsd:boolean'
        bool *GetCacheMethodListResult;
        /// Optional element 'ns1:methodNames' of XSD type 'ns2:ArrayOfstring'
        ns2__ArrayOfstring *methodNames;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCacheMethodListResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetCacheMethodListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCacheMethodListResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCacheMethodListResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetCacheMethodListResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCacheMethodListResponse()
        {
          GetCacheMethodListResult = (bool *)0;
          methodNames = (ns2__ArrayOfstring *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetCacheMethodListResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCacheMethodListResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCacheMethodListResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCacheMethodListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:597 */
#ifndef SOAP_TYPE_ns2__ArrayOfbase64Binary
#define SOAP_TYPE_ns2__ArrayOfbase64Binary (138)
/* Type ns2__ArrayOfbase64Binary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOfbase64Binary': */
class SOAP_CMAC ns2__ArrayOfbase64Binary : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:base64Binary' of XSD type 'xsd:base64Binary' stored in dynamic array base64Binary of length __sizebase64Binary
        int __sizebase64Binary;
        xsd__base64Binary *base64Binary;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfbase64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfbase64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfbase64Binary, default initialized and not managed by a soap context
        virtual ns2__ArrayOfbase64Binary *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfbase64Binary); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfbase64Binary()
        {
          __sizebase64Binary = 0;
          base64Binary = NULL;
        }
        virtual ~ns2__ArrayOfbase64Binary() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfbase64Binary(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfbase64Binary * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfbase64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:600 */
#ifndef SOAP_TYPE_ns2__ArrayOfint
#define SOAP_TYPE_ns2__ArrayOfint (139)
/* Type ns2__ArrayOfint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOfint': */
class SOAP_CMAC ns2__ArrayOfint : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:int' of XSD type 'xsd:int' stored in dynamic array int_ of length __sizeint_
        int __sizeint_;
        int *int_;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfint
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfint, default initialized and not managed by a soap context
        virtual ns2__ArrayOfint *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfint); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfint()
        {
          __sizeint_ = 0;
          int_ = NULL;
        }
        virtual ~ns2__ArrayOfint() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfint(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfint * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:603 */
#ifndef SOAP_TYPE_ns2__ArrayOflong
#define SOAP_TYPE_ns2__ArrayOflong (140)
/* Type ns2__ArrayOflong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOflong': */
class SOAP_CMAC ns2__ArrayOflong : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:long' of XSD type 'xsd:long' stored in dynamic array long_ of length __sizelong_
        int __sizelong_;
        LONG64 *long_;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOflong
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOflong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOflong, default initialized and not managed by a soap context
        virtual ns2__ArrayOflong *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOflong); }
      public:
        /// Constructor with initializations
        ns2__ArrayOflong()
        {
          __sizelong_ = 0;
          long_ = NULL;
        }
        virtual ~ns2__ArrayOflong() { }
        /// Friend allocator used by soap_new_ns2__ArrayOflong(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOflong * SOAP_FMAC2 soap_instantiate_ns2__ArrayOflong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:3305 */
#ifndef SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (166)
/* complex XSD type 'ns2:ArrayOfKeyValueOfstringstring-KeyValueOfstringstring': */
class SOAP_CMAC _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns2:Key' of XSD type 'xsd:string'
        char *Key;
        /// Required nillable (xsi:nil when NULL) element 'ns2:Value' of XSD type 'xsd:string'
        char *Value;
      public:
        /// Return unique type id SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
        virtual int soap_type(void) const { return SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring, default initialized and not managed by a soap context
        virtual _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring *soap_alloc(void) const { return SOAP_NEW(_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring); }
      public:
        /// Constructor with initializations
        _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring()
        {
          Key = (char *)0;
          Value = (char *)0;
        }
        virtual ~_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring() { }
        /// Friend allocator used by soap_new__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring(struct soap*, int)
        friend SOAP_FMAC1 _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring * SOAP_FMAC2 soap_instantiate__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:606 */
#ifndef SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring (141)
/* Type ns2__ArrayOfKeyValueOfstringstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOfKeyValueOfstringstring': */
class SOAP_CMAC ns2__ArrayOfKeyValueOfstringstring : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:KeyValueOfstringstring' of XSD type 'ns2:ArrayOfKeyValueOfstringstring-KeyValueOfstringstring' stored in dynamic array KeyValueOfstringstring of length __sizeKeyValueOfstringstring
        int __sizeKeyValueOfstringstring;
        _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring *KeyValueOfstringstring;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfKeyValueOfstringstring, default initialized and not managed by a soap context
        virtual ns2__ArrayOfKeyValueOfstringstring *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfKeyValueOfstringstring); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfKeyValueOfstringstring()
        {
          __sizeKeyValueOfstringstring = 0;
          KeyValueOfstringstring = NULL;
        }
        virtual ~ns2__ArrayOfKeyValueOfstringstring() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfKeyValueOfstringstring(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfKeyValueOfstringstring * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfKeyValueOfstringstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:609 */
#ifndef SOAP_TYPE_ns2__ArrayOfstring
#define SOAP_TYPE_ns2__ArrayOfstring (142)
/* Type ns2__ArrayOfstring is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ArrayOfstring': */
class SOAP_CMAC ns2__ArrayOfstring : public xsd__anyType {
      public:
        /// Sequence of elements 'ns2:string' of XSD type 'xsd:string' stored in dynamic array string of length __sizestring
        int __sizestring;
        char **string;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ArrayOfstring
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ArrayOfstring, default initialized and not managed by a soap context
        virtual ns2__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW(ns2__ArrayOfstring); }
      public:
        /// Constructor with initializations
        ns2__ArrayOfstring()
        {
          __sizestring = 0;
          string = NULL;
        }
        virtual ~ns2__ArrayOfstring() { }
        /// Friend allocator used by soap_new_ns2__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 ns2__ArrayOfstring * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:612 */
#ifndef SOAP_TYPE_ns3__CustomMessageScreen
#define SOAP_TYPE_ns3__CustomMessageScreen (143)
/* Type ns3__CustomMessageScreen is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:CustomMessageScreen': */
class SOAP_CMAC ns3__CustomMessageScreen : public xsd__anyType {
      public:
        /// Optional element 'ns3:MessageLines' of XSD type 'ns3:ArrayOfCustomMessageLine'
        ns3__ArrayOfCustomMessageLine *MessageLines;
        /// Optional element 'ns3:ScreenType' of XSD type 'xsd:string'
        char *ScreenType;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CustomMessageScreen
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CustomMessageScreen; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CustomMessageScreen, default initialized and not managed by a soap context
        virtual ns3__CustomMessageScreen *soap_alloc(void) const { return SOAP_NEW(ns3__CustomMessageScreen); }
      public:
        /// Constructor with initializations
        ns3__CustomMessageScreen()
        {
          MessageLines = (ns3__ArrayOfCustomMessageLine *)0;
          ScreenType = (char *)0;
        }
        virtual ~ns3__CustomMessageScreen() { }
        /// Friend allocator used by soap_new_ns3__CustomMessageScreen(struct soap*, int)
        friend SOAP_FMAC1 ns3__CustomMessageScreen * SOAP_FMAC2 soap_instantiate_ns3__CustomMessageScreen(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:615 */
#ifndef SOAP_TYPE_ns3__ArrayOfCustomMessageLine
#define SOAP_TYPE_ns3__ArrayOfCustomMessageLine (144)
/* Type ns3__ArrayOfCustomMessageLine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:ArrayOfCustomMessageLine': */
class SOAP_CMAC ns3__ArrayOfCustomMessageLine : public xsd__anyType {
      public:
        /// Sequence of elements 'ns3:CustomMessageLine' of XSD type 'ns3:CustomMessageLine' stored in dynamic array CustomMessageLine of length __sizeCustomMessageLine
        int __sizeCustomMessageLine;
        ns3__CustomMessageLine **CustomMessageLine;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfCustomMessageLine
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfCustomMessageLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfCustomMessageLine, default initialized and not managed by a soap context
        virtual ns3__ArrayOfCustomMessageLine *soap_alloc(void) const { return SOAP_NEW(ns3__ArrayOfCustomMessageLine); }
      public:
        /// Constructor with initializations
        ns3__ArrayOfCustomMessageLine()
        {
          __sizeCustomMessageLine = 0;
          CustomMessageLine = NULL;
        }
        virtual ~ns3__ArrayOfCustomMessageLine() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfCustomMessageLine(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfCustomMessageLine * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfCustomMessageLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:618 */
#ifndef SOAP_TYPE_ns3__CustomMessageLine
#define SOAP_TYPE_ns3__CustomMessageLine (145)
/* Type ns3__CustomMessageLine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns3:CustomMessageLine': */
class SOAP_CMAC ns3__CustomMessageLine : public xsd__anyType {
      public:
        /// Optional element 'ns3:Bold' of XSD type 'xsd:boolean'
        bool *Bold;
        /// Optional element 'ns3:DropShadow' of XSD type 'xsd:boolean'
        bool *DropShadow;
        /// Optional element 'ns3:FontName' of XSD type 'xsd:string'
        char *FontName;
        /// Optional element 'ns3:FontSize' of XSD type 'xsd:int'
        int *FontSize;
        /// Optional element 'ns3:ForegroundColor' of XSD type 'xsd:unsignedInt'
        unsigned int *ForegroundColor;
        /// Optional element 'ns3:Italic' of XSD type 'xsd:boolean'
        bool *Italic;
        /// Optional element 'ns3:JustificationType' of XSD type 'ns3:EventData.CustomMessageJustificationType'
        enum ns3__EventData_x002eCustomMessageJustificationType *JustificationType;
        /// Optional element 'ns3:Text' of XSD type 'xsd:string'
        char *Text;
        /// Optional element 'ns3:Underline' of XSD type 'xsd:boolean'
        bool *Underline;
        /// Optional element 'ns3:X1' of XSD type 'xsd:int'
        int *X1;
        /// Optional element 'ns3:X2' of XSD type 'xsd:int'
        int *X2;
        /// Optional element 'ns3:Y1' of XSD type 'xsd:int'
        int *Y1;
        /// Optional element 'ns3:Y2' of XSD type 'xsd:int'
        int *Y2;
      public:
        /// Return unique type id SOAP_TYPE_ns3__CustomMessageLine
        virtual int soap_type(void) const { return SOAP_TYPE_ns3__CustomMessageLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__CustomMessageLine, default initialized and not managed by a soap context
        virtual ns3__CustomMessageLine *soap_alloc(void) const { return SOAP_NEW(ns3__CustomMessageLine); }
      public:
        /// Constructor with initializations
        ns3__CustomMessageLine()
        {
          Bold = (bool *)0;
          DropShadow = (bool *)0;
          FontName = (char *)0;
          FontSize = (int *)0;
          ForegroundColor = (unsigned int *)0;
          Italic = (bool *)0;
          JustificationType = (enum ns3__EventData_x002eCustomMessageJustificationType *)0;
          Text = (char *)0;
          Underline = (bool *)0;
          X1 = (int *)0;
          X2 = (int *)0;
          Y1 = (int *)0;
          Y2 = (int *)0;
        }
        virtual ~ns3__CustomMessageLine() { }
        /// Friend allocator used by soap_new_ns3__CustomMessageLine(struct soap*, int)
        friend SOAP_FMAC1 ns3__CustomMessageLine * SOAP_FMAC2 soap_instantiate_ns3__CustomMessageLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:3826 */
#ifndef SOAP_TYPE___ns1__Checkin
#define SOAP_TYPE___ns1__Checkin (177)
/* Wrapper: */
struct SOAP_CMAC __ns1__Checkin {
      public:
        /** Optional element 'ns1:Checkin' of XSD type 'ns1:Checkin' */
        _ns1__Checkin *ns1__Checkin;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Checkin */
        int soap_type() const { return SOAP_TYPE___ns1__Checkin; }
        /** Constructor with member initializations */
        __ns1__Checkin()
        {
          ns1__Checkin = (_ns1__Checkin *)0;
        }
        /** Friend allocator used by soap_new___ns1__Checkin(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Checkin * SOAP_FMAC2 soap_instantiate___ns1__Checkin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:3896 */
#ifndef SOAP_TYPE___ns1__GetEventStartNotification
#define SOAP_TYPE___ns1__GetEventStartNotification (181)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEventStartNotification {
      public:
        /** Optional element 'ns1:GetEventStartNotification' of XSD type 'ns1:GetEventStartNotification' */
        _ns1__GetEventStartNotification *ns1__GetEventStartNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEventStartNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetEventStartNotification; }
        /** Constructor with member initializations */
        __ns1__GetEventStartNotification()
        {
          ns1__GetEventStartNotification = (_ns1__GetEventStartNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetEventStartNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetEventStartNotification * SOAP_FMAC2 soap_instantiate___ns1__GetEventStartNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:3966 */
#ifndef SOAP_TYPE___ns1__GetEventStartNotificationV25
#define SOAP_TYPE___ns1__GetEventStartNotificationV25 (185)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEventStartNotificationV25 {
      public:
        /** Optional element 'ns1:GetEventStartNotificationV25' of XSD type 'ns1:GetEventStartNotificationV25' */
        _ns1__GetEventStartNotificationV25 *ns1__GetEventStartNotificationV25;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEventStartNotificationV25 */
        int soap_type() const { return SOAP_TYPE___ns1__GetEventStartNotificationV25; }
        /** Constructor with member initializations */
        __ns1__GetEventStartNotificationV25()
        {
          ns1__GetEventStartNotificationV25 = (_ns1__GetEventStartNotificationV25 *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetEventStartNotificationV25(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetEventStartNotificationV25 * SOAP_FMAC2 soap_instantiate___ns1__GetEventStartNotificationV25(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4036 */
#ifndef SOAP_TYPE___ns1__GetCMPStatusNotification
#define SOAP_TYPE___ns1__GetCMPStatusNotification (189)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCMPStatusNotification {
      public:
        /** Optional element 'ns1:GetCMPStatusNotification' of XSD type 'ns1:GetCMPStatusNotification' */
        _ns1__GetCMPStatusNotification *ns1__GetCMPStatusNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCMPStatusNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetCMPStatusNotification; }
        /** Constructor with member initializations */
        __ns1__GetCMPStatusNotification()
        {
          ns1__GetCMPStatusNotification = (_ns1__GetCMPStatusNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCMPStatusNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCMPStatusNotification * SOAP_FMAC2 soap_instantiate___ns1__GetCMPStatusNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4106 */
#ifndef SOAP_TYPE___ns1__GetSentinelConfigNotification
#define SOAP_TYPE___ns1__GetSentinelConfigNotification (193)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSentinelConfigNotification {
      public:
        /** Optional element 'ns1:GetSentinelConfigNotification' of XSD type 'ns1:GetSentinelConfigNotification' */
        _ns1__GetSentinelConfigNotification *ns1__GetSentinelConfigNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSentinelConfigNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetSentinelConfigNotification; }
        /** Constructor with member initializations */
        __ns1__GetSentinelConfigNotification()
        {
          ns1__GetSentinelConfigNotification = (_ns1__GetSentinelConfigNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSentinelConfigNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSentinelConfigNotification * SOAP_FMAC2 soap_instantiate___ns1__GetSentinelConfigNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4176 */
#ifndef SOAP_TYPE___ns1__GetSplashdownTriggeredEventNotificationCustom
#define SOAP_TYPE___ns1__GetSplashdownTriggeredEventNotificationCustom (197)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSplashdownTriggeredEventNotificationCustom {
      public:
        /** Optional element 'ns1:GetSplashdownTriggeredEventNotificationCustom' of XSD type 'ns1:GetSplashdownTriggeredEventNotificationCustom' */
        _ns1__GetSplashdownTriggeredEventNotificationCustom *ns1__GetSplashdownTriggeredEventNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSplashdownTriggeredEventNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetSplashdownTriggeredEventNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetSplashdownTriggeredEventNotificationCustom()
        {
          ns1__GetSplashdownTriggeredEventNotificationCustom = (_ns1__GetSplashdownTriggeredEventNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSplashdownTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4246 */
#ifndef SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustom
#define SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustom (201)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSplashdownAwardNotificationCustom {
      public:
        /** Optional element 'ns1:GetSplashdownAwardNotificationCustom' of XSD type 'ns1:GetSplashdownAwardNotificationCustom' */
        _ns1__GetSplashdownAwardNotificationCustom *ns1__GetSplashdownAwardNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetSplashdownAwardNotificationCustom()
        {
          ns1__GetSplashdownAwardNotificationCustom = (_ns1__GetSplashdownAwardNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSplashdownAwardNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSplashdownAwardNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetSplashdownAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4316 */
#ifndef SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustomWithMediaData
#define SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustomWithMediaData (205)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSplashdownAwardNotificationCustomWithMediaData {
      public:
        /** Optional element 'ns1:GetSplashdownAwardNotificationCustomWithMediaData' of XSD type 'ns1:GetSplashdownAwardNotificationCustomWithMediaData' */
        _ns1__GetSplashdownAwardNotificationCustomWithMediaData *ns1__GetSplashdownAwardNotificationCustomWithMediaData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustomWithMediaData */
        int soap_type() const { return SOAP_TYPE___ns1__GetSplashdownAwardNotificationCustomWithMediaData; }
        /** Constructor with member initializations */
        __ns1__GetSplashdownAwardNotificationCustomWithMediaData()
        {
          ns1__GetSplashdownAwardNotificationCustomWithMediaData = (_ns1__GetSplashdownAwardNotificationCustomWithMediaData *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSplashdownAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate___ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4386 */
#ifndef SOAP_TYPE___ns1__GetRicochetTriggeredEventNotificationCustom
#define SOAP_TYPE___ns1__GetRicochetTriggeredEventNotificationCustom (209)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRicochetTriggeredEventNotificationCustom {
      public:
        /** Optional element 'ns1:GetRicochetTriggeredEventNotificationCustom' of XSD type 'ns1:GetRicochetTriggeredEventNotificationCustom' */
        _ns1__GetRicochetTriggeredEventNotificationCustom *ns1__GetRicochetTriggeredEventNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRicochetTriggeredEventNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetRicochetTriggeredEventNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetRicochetTriggeredEventNotificationCustom()
        {
          ns1__GetRicochetTriggeredEventNotificationCustom = (_ns1__GetRicochetTriggeredEventNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRicochetTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4456 */
#ifndef SOAP_TYPE___ns1__GetRicochetAwardNotificationCustom
#define SOAP_TYPE___ns1__GetRicochetAwardNotificationCustom (213)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRicochetAwardNotificationCustom {
      public:
        /** Optional element 'ns1:GetRicochetAwardNotificationCustom' of XSD type 'ns1:GetRicochetAwardNotificationCustom' */
        _ns1__GetRicochetAwardNotificationCustom *ns1__GetRicochetAwardNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRicochetAwardNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetRicochetAwardNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetRicochetAwardNotificationCustom()
        {
          ns1__GetRicochetAwardNotificationCustom = (_ns1__GetRicochetAwardNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRicochetAwardNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRicochetAwardNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetRicochetAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4526 */
#ifndef SOAP_TYPE___ns1__GetRicochetAwardNotificationCustomWithMediaData
#define SOAP_TYPE___ns1__GetRicochetAwardNotificationCustomWithMediaData (217)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetRicochetAwardNotificationCustomWithMediaData {
      public:
        /** Optional element 'ns1:GetRicochetAwardNotificationCustomWithMediaData' of XSD type 'ns1:GetRicochetAwardNotificationCustomWithMediaData' */
        _ns1__GetRicochetAwardNotificationCustomWithMediaData *ns1__GetRicochetAwardNotificationCustomWithMediaData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetRicochetAwardNotificationCustomWithMediaData */
        int soap_type() const { return SOAP_TYPE___ns1__GetRicochetAwardNotificationCustomWithMediaData; }
        /** Constructor with member initializations */
        __ns1__GetRicochetAwardNotificationCustomWithMediaData()
        {
          ns1__GetRicochetAwardNotificationCustomWithMediaData = (_ns1__GetRicochetAwardNotificationCustomWithMediaData *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetRicochetAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate___ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4596 */
#ifndef SOAP_TYPE___ns1__GetJackpotAnnouncementNotification
#define SOAP_TYPE___ns1__GetJackpotAnnouncementNotification (221)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetJackpotAnnouncementNotification {
      public:
        /** Optional element 'ns1:GetJackpotAnnouncementNotification' of XSD type 'ns1:GetJackpotAnnouncementNotification' */
        _ns1__GetJackpotAnnouncementNotification *ns1__GetJackpotAnnouncementNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetJackpotAnnouncementNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetJackpotAnnouncementNotification; }
        /** Constructor with member initializations */
        __ns1__GetJackpotAnnouncementNotification()
        {
          ns1__GetJackpotAnnouncementNotification = (_ns1__GetJackpotAnnouncementNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetJackpotAnnouncementNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetJackpotAnnouncementNotification * SOAP_FMAC2 soap_instantiate___ns1__GetJackpotAnnouncementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4666 */
#ifndef SOAP_TYPE___ns1__GetTriggerlessAnnouncementNotification
#define SOAP_TYPE___ns1__GetTriggerlessAnnouncementNotification (225)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTriggerlessAnnouncementNotification {
      public:
        /** Optional element 'ns1:GetTriggerlessAnnouncementNotification' of XSD type 'ns1:GetTriggerlessAnnouncementNotification' */
        _ns1__GetTriggerlessAnnouncementNotification *ns1__GetTriggerlessAnnouncementNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTriggerlessAnnouncementNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetTriggerlessAnnouncementNotification; }
        /** Constructor with member initializations */
        __ns1__GetTriggerlessAnnouncementNotification()
        {
          ns1__GetTriggerlessAnnouncementNotification = (_ns1__GetTriggerlessAnnouncementNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetTriggerlessAnnouncementNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetTriggerlessAnnouncementNotification * SOAP_FMAC2 soap_instantiate___ns1__GetTriggerlessAnnouncementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4736 */
#ifndef SOAP_TYPE___ns1__GetExternalPaidNotification
#define SOAP_TYPE___ns1__GetExternalPaidNotification (229)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetExternalPaidNotification {
      public:
        /** Optional element 'ns1:GetExternalPaidNotification' of XSD type 'ns1:GetExternalPaidNotification' */
        _ns1__GetExternalPaidNotification *ns1__GetExternalPaidNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetExternalPaidNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetExternalPaidNotification; }
        /** Constructor with member initializations */
        __ns1__GetExternalPaidNotification()
        {
          ns1__GetExternalPaidNotification = (_ns1__GetExternalPaidNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetExternalPaidNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetExternalPaidNotification * SOAP_FMAC2 soap_instantiate___ns1__GetExternalPaidNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4806 */
#ifndef SOAP_TYPE___ns1__GetTriggerRejectedNotification
#define SOAP_TYPE___ns1__GetTriggerRejectedNotification (233)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTriggerRejectedNotification {
      public:
        /** Optional element 'ns1:GetTriggerRejectedNotification' of XSD type 'ns1:GetTriggerRejectedNotification' */
        _ns1__GetTriggerRejectedNotification *ns1__GetTriggerRejectedNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTriggerRejectedNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetTriggerRejectedNotification; }
        /** Constructor with member initializations */
        __ns1__GetTriggerRejectedNotification()
        {
          ns1__GetTriggerRejectedNotification = (_ns1__GetTriggerRejectedNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetTriggerRejectedNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetTriggerRejectedNotification * SOAP_FMAC2 soap_instantiate___ns1__GetTriggerRejectedNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4876 */
#ifndef SOAP_TYPE___ns1__GetSpeedMediaVersion
#define SOAP_TYPE___ns1__GetSpeedMediaVersion (237)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetSpeedMediaVersion {
      public:
        /** Optional element 'ns1:GetSpeedMediaVersion' of XSD type 'ns1:GetSpeedMediaVersion' */
        _ns1__GetSpeedMediaVersion *ns1__GetSpeedMediaVersion;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetSpeedMediaVersion */
        int soap_type() const { return SOAP_TYPE___ns1__GetSpeedMediaVersion; }
        /** Constructor with member initializations */
        __ns1__GetSpeedMediaVersion()
        {
          ns1__GetSpeedMediaVersion = (_ns1__GetSpeedMediaVersion *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetSpeedMediaVersion(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetSpeedMediaVersion * SOAP_FMAC2 soap_instantiate___ns1__GetSpeedMediaVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:4946 */
#ifndef SOAP_TYPE___ns1__CardIn
#define SOAP_TYPE___ns1__CardIn (241)
/* Wrapper: */
struct SOAP_CMAC __ns1__CardIn {
      public:
        /** Optional element 'ns1:CardIn' of XSD type 'ns1:CardIn' */
        _ns1__CardIn *ns1__CardIn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CardIn */
        int soap_type() const { return SOAP_TYPE___ns1__CardIn; }
        /** Constructor with member initializations */
        __ns1__CardIn()
        {
          ns1__CardIn = (_ns1__CardIn *)0;
        }
        /** Friend allocator used by soap_new___ns1__CardIn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CardIn * SOAP_FMAC2 soap_instantiate___ns1__CardIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5016 */
#ifndef SOAP_TYPE___ns1__CardOut
#define SOAP_TYPE___ns1__CardOut (245)
/* Wrapper: */
struct SOAP_CMAC __ns1__CardOut {
      public:
        /** Optional element 'ns1:CardOut' of XSD type 'ns1:CardOut' */
        _ns1__CardOut *ns1__CardOut;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CardOut */
        int soap_type() const { return SOAP_TYPE___ns1__CardOut; }
        /** Constructor with member initializations */
        __ns1__CardOut()
        {
          ns1__CardOut = (_ns1__CardOut *)0;
        }
        /** Friend allocator used by soap_new___ns1__CardOut(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CardOut * SOAP_FMAC2 soap_instantiate___ns1__CardOut(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5086 */
#ifndef SOAP_TYPE___ns1__GamePlayedAfterCardIn
#define SOAP_TYPE___ns1__GamePlayedAfterCardIn (249)
/* Wrapper: */
struct SOAP_CMAC __ns1__GamePlayedAfterCardIn {
      public:
        /** Optional element 'ns1:GamePlayedAfterCardIn' of XSD type 'ns1:GamePlayedAfterCardIn' */
        _ns1__GamePlayedAfterCardIn *ns1__GamePlayedAfterCardIn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GamePlayedAfterCardIn */
        int soap_type() const { return SOAP_TYPE___ns1__GamePlayedAfterCardIn; }
        /** Constructor with member initializations */
        __ns1__GamePlayedAfterCardIn()
        {
          ns1__GamePlayedAfterCardIn = (_ns1__GamePlayedAfterCardIn *)0;
        }
        /** Friend allocator used by soap_new___ns1__GamePlayedAfterCardIn(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GamePlayedAfterCardIn * SOAP_FMAC2 soap_instantiate___ns1__GamePlayedAfterCardIn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5156 */
#ifndef SOAP_TYPE___ns1__RequestNonCardedEvents
#define SOAP_TYPE___ns1__RequestNonCardedEvents (253)
/* Wrapper: */
struct SOAP_CMAC __ns1__RequestNonCardedEvents {
      public:
        /** Optional element 'ns1:RequestNonCardedEvents' of XSD type 'ns1:RequestNonCardedEvents' */
        _ns1__RequestNonCardedEvents *ns1__RequestNonCardedEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RequestNonCardedEvents */
        int soap_type() const { return SOAP_TYPE___ns1__RequestNonCardedEvents; }
        /** Constructor with member initializations */
        __ns1__RequestNonCardedEvents()
        {
          ns1__RequestNonCardedEvents = (_ns1__RequestNonCardedEvents *)0;
        }
        /** Friend allocator used by soap_new___ns1__RequestNonCardedEvents(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RequestNonCardedEvents * SOAP_FMAC2 soap_instantiate___ns1__RequestNonCardedEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5226 */
#ifndef SOAP_TYPE___ns1__GetFlashStartAnnouncement
#define SOAP_TYPE___ns1__GetFlashStartAnnouncement (257)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFlashStartAnnouncement {
      public:
        /** Optional element 'ns1:GetFlashStartAnnouncement' of XSD type 'ns1:GetFlashStartAnnouncement' */
        _ns1__GetFlashStartAnnouncement *ns1__GetFlashStartAnnouncement;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFlashStartAnnouncement */
        int soap_type() const { return SOAP_TYPE___ns1__GetFlashStartAnnouncement; }
        /** Constructor with member initializations */
        __ns1__GetFlashStartAnnouncement()
        {
          ns1__GetFlashStartAnnouncement = (_ns1__GetFlashStartAnnouncement *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetFlashStartAnnouncement(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetFlashStartAnnouncement * SOAP_FMAC2 soap_instantiate___ns1__GetFlashStartAnnouncement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5296 */
#ifndef SOAP_TYPE___ns1__GetFlashUdpCompleteAnnouncement
#define SOAP_TYPE___ns1__GetFlashUdpCompleteAnnouncement (261)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFlashUdpCompleteAnnouncement {
      public:
        /** Optional element 'ns1:GetFlashUdpCompleteAnnouncement' of XSD type 'ns1:GetFlashUdpCompleteAnnouncement' */
        _ns1__GetFlashUdpCompleteAnnouncement *ns1__GetFlashUdpCompleteAnnouncement;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFlashUdpCompleteAnnouncement */
        int soap_type() const { return SOAP_TYPE___ns1__GetFlashUdpCompleteAnnouncement; }
        /** Constructor with member initializations */
        __ns1__GetFlashUdpCompleteAnnouncement()
        {
          ns1__GetFlashUdpCompleteAnnouncement = (_ns1__GetFlashUdpCompleteAnnouncement *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetFlashUdpCompleteAnnouncement(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetFlashUdpCompleteAnnouncement * SOAP_FMAC2 soap_instantiate___ns1__GetFlashUdpCompleteAnnouncement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5366 */
#ifndef SOAP_TYPE___ns1__GetFileInformation
#define SOAP_TYPE___ns1__GetFileInformation (265)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFileInformation {
      public:
        /** Optional element 'ns1:GetFileInformation' of XSD type 'ns1:GetFileInformation' */
        _ns1__GetFileInformation *ns1__GetFileInformation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFileInformation */
        int soap_type() const { return SOAP_TYPE___ns1__GetFileInformation; }
        /** Constructor with member initializations */
        __ns1__GetFileInformation()
        {
          ns1__GetFileInformation = (_ns1__GetFileInformation *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetFileInformation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetFileInformation * SOAP_FMAC2 soap_instantiate___ns1__GetFileInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5436 */
#ifndef SOAP_TYPE___ns1__GetConfig
#define SOAP_TYPE___ns1__GetConfig (269)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetConfig {
      public:
        /** Optional element 'ns1:GetConfig' of XSD type 'ns1:GetConfig' */
        _ns1__GetConfig *ns1__GetConfig;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetConfig */
        int soap_type() const { return SOAP_TYPE___ns1__GetConfig; }
        /** Constructor with member initializations */
        __ns1__GetConfig()
        {
          ns1__GetConfig = (_ns1__GetConfig *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetConfig(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetConfig * SOAP_FMAC2 soap_instantiate___ns1__GetConfig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5506 */
#ifndef SOAP_TYPE___ns1__GetConfigEx
#define SOAP_TYPE___ns1__GetConfigEx (273)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetConfigEx {
      public:
        /** Optional element 'ns1:GetConfigEx' of XSD type 'ns1:GetConfigEx' */
        _ns1__GetConfigEx *ns1__GetConfigEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetConfigEx */
        int soap_type() const { return SOAP_TYPE___ns1__GetConfigEx; }
        /** Constructor with member initializations */
        __ns1__GetConfigEx()
        {
          ns1__GetConfigEx = (_ns1__GetConfigEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetConfigEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetConfigEx * SOAP_FMAC2 soap_instantiate___ns1__GetConfigEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5576 */
#ifndef SOAP_TYPE___ns1__GetEventXMLFile
#define SOAP_TYPE___ns1__GetEventXMLFile (277)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEventXMLFile {
      public:
        /** Optional element 'ns1:GetEventXMLFile' of XSD type 'ns1:GetEventXMLFile' */
        _ns1__GetEventXMLFile *ns1__GetEventXMLFile;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEventXMLFile */
        int soap_type() const { return SOAP_TYPE___ns1__GetEventXMLFile; }
        /** Constructor with member initializations */
        __ns1__GetEventXMLFile()
        {
          ns1__GetEventXMLFile = (_ns1__GetEventXMLFile *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetEventXMLFile(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetEventXMLFile * SOAP_FMAC2 soap_instantiate___ns1__GetEventXMLFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5646 */
#ifndef SOAP_TYPE___ns1__InEventTrigger
#define SOAP_TYPE___ns1__InEventTrigger (281)
/* Wrapper: */
struct SOAP_CMAC __ns1__InEventTrigger {
      public:
        /** Optional element 'ns1:InEventTrigger' of XSD type 'ns1:InEventTrigger' */
        _ns1__InEventTrigger *ns1__InEventTrigger;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InEventTrigger */
        int soap_type() const { return SOAP_TYPE___ns1__InEventTrigger; }
        /** Constructor with member initializations */
        __ns1__InEventTrigger()
        {
          ns1__InEventTrigger = (_ns1__InEventTrigger *)0;
        }
        /** Friend allocator used by soap_new___ns1__InEventTrigger(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__InEventTrigger * SOAP_FMAC2 soap_instantiate___ns1__InEventTrigger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5716 */
#ifndef SOAP_TYPE___ns1__InTriggeredEventTrigger
#define SOAP_TYPE___ns1__InTriggeredEventTrigger (285)
/* Wrapper: */
struct SOAP_CMAC __ns1__InTriggeredEventTrigger {
      public:
        /** Optional element 'ns1:InTriggeredEventTrigger' of XSD type 'ns1:InTriggeredEventTrigger' */
        _ns1__InTriggeredEventTrigger *ns1__InTriggeredEventTrigger;
      public:
        /** Return unique type id SOAP_TYPE___ns1__InTriggeredEventTrigger */
        int soap_type() const { return SOAP_TYPE___ns1__InTriggeredEventTrigger; }
        /** Constructor with member initializations */
        __ns1__InTriggeredEventTrigger()
        {
          ns1__InTriggeredEventTrigger = (_ns1__InTriggeredEventTrigger *)0;
        }
        /** Friend allocator used by soap_new___ns1__InTriggeredEventTrigger(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__InTriggeredEventTrigger * SOAP_FMAC2 soap_instantiate___ns1__InTriggeredEventTrigger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5786 */
#ifndef SOAP_TYPE___ns1__ReportEventMeterDeltas
#define SOAP_TYPE___ns1__ReportEventMeterDeltas (289)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportEventMeterDeltas {
      public:
        /** Optional element 'ns1:ReportEventMeterDeltas' of XSD type 'ns1:ReportEventMeterDeltas' */
        _ns1__ReportEventMeterDeltas *ns1__ReportEventMeterDeltas;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportEventMeterDeltas */
        int soap_type() const { return SOAP_TYPE___ns1__ReportEventMeterDeltas; }
        /** Constructor with member initializations */
        __ns1__ReportEventMeterDeltas()
        {
          ns1__ReportEventMeterDeltas = (_ns1__ReportEventMeterDeltas *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportEventMeterDeltas(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportEventMeterDeltas * SOAP_FMAC2 soap_instantiate___ns1__ReportEventMeterDeltas(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5856 */
#ifndef SOAP_TYPE___ns1__ReportGameStart
#define SOAP_TYPE___ns1__ReportGameStart (293)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportGameStart {
      public:
        /** Optional element 'ns1:ReportGameStart' of XSD type 'ns1:ReportGameStart' */
        _ns1__ReportGameStart *ns1__ReportGameStart;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportGameStart */
        int soap_type() const { return SOAP_TYPE___ns1__ReportGameStart; }
        /** Constructor with member initializations */
        __ns1__ReportGameStart()
        {
          ns1__ReportGameStart = (_ns1__ReportGameStart *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportGameStart(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportGameStart * SOAP_FMAC2 soap_instantiate___ns1__ReportGameStart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5926 */
#ifndef SOAP_TYPE___ns1__AcknowledgeExternalPaid
#define SOAP_TYPE___ns1__AcknowledgeExternalPaid (297)
/* Wrapper: */
struct SOAP_CMAC __ns1__AcknowledgeExternalPaid {
      public:
        /** Optional element 'ns1:AcknowledgeExternalPaid' of XSD type 'ns1:AcknowledgeExternalPaid' */
        _ns1__AcknowledgeExternalPaid *ns1__AcknowledgeExternalPaid;
      public:
        /** Return unique type id SOAP_TYPE___ns1__AcknowledgeExternalPaid */
        int soap_type() const { return SOAP_TYPE___ns1__AcknowledgeExternalPaid; }
        /** Constructor with member initializations */
        __ns1__AcknowledgeExternalPaid()
        {
          ns1__AcknowledgeExternalPaid = (_ns1__AcknowledgeExternalPaid *)0;
        }
        /** Friend allocator used by soap_new___ns1__AcknowledgeExternalPaid(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__AcknowledgeExternalPaid * SOAP_FMAC2 soap_instantiate___ns1__AcknowledgeExternalPaid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:5996 */
#ifndef SOAP_TYPE___ns1__ReportStatus
#define SOAP_TYPE___ns1__ReportStatus (301)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportStatus {
      public:
        /** Optional element 'ns1:ReportStatus' of XSD type 'ns1:ReportStatus' */
        _ns1__ReportStatus *ns1__ReportStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportStatus */
        int soap_type() const { return SOAP_TYPE___ns1__ReportStatus; }
        /** Constructor with member initializations */
        __ns1__ReportStatus()
        {
          ns1__ReportStatus = (_ns1__ReportStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportStatus * SOAP_FMAC2 soap_instantiate___ns1__ReportStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6066 */
#ifndef SOAP_TYPE___ns1__ReportSentinelInformation
#define SOAP_TYPE___ns1__ReportSentinelInformation (305)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportSentinelInformation {
      public:
        /** Optional element 'ns1:ReportSentinelInformation' of XSD type 'ns1:ReportSentinelInformation' */
        _ns1__ReportSentinelInformation *ns1__ReportSentinelInformation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportSentinelInformation */
        int soap_type() const { return SOAP_TYPE___ns1__ReportSentinelInformation; }
        /** Constructor with member initializations */
        __ns1__ReportSentinelInformation()
        {
          ns1__ReportSentinelInformation = (_ns1__ReportSentinelInformation *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportSentinelInformation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportSentinelInformation * SOAP_FMAC2 soap_instantiate___ns1__ReportSentinelInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6136 */
#ifndef SOAP_TYPE___ns1__ReportSentinelInformationWithOrientation
#define SOAP_TYPE___ns1__ReportSentinelInformationWithOrientation (309)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportSentinelInformationWithOrientation {
      public:
        /** Optional element 'ns1:ReportSentinelInformationWithOrientation' of XSD type 'ns1:ReportSentinelInformationWithOrientation' */
        _ns1__ReportSentinelInformationWithOrientation *ns1__ReportSentinelInformationWithOrientation;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportSentinelInformationWithOrientation */
        int soap_type() const { return SOAP_TYPE___ns1__ReportSentinelInformationWithOrientation; }
        /** Constructor with member initializations */
        __ns1__ReportSentinelInformationWithOrientation()
        {
          ns1__ReportSentinelInformationWithOrientation = (_ns1__ReportSentinelInformationWithOrientation *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportSentinelInformationWithOrientation(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportSentinelInformationWithOrientation * SOAP_FMAC2 soap_instantiate___ns1__ReportSentinelInformationWithOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6206 */
#ifndef SOAP_TYPE___ns1__ReportSentinelInformationEx
#define SOAP_TYPE___ns1__ReportSentinelInformationEx (313)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportSentinelInformationEx {
      public:
        /** Optional element 'ns1:ReportSentinelInformationEx' of XSD type 'ns1:ReportSentinelInformationEx' */
        _ns1__ReportSentinelInformationEx *ns1__ReportSentinelInformationEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportSentinelInformationEx */
        int soap_type() const { return SOAP_TYPE___ns1__ReportSentinelInformationEx; }
        /** Constructor with member initializations */
        __ns1__ReportSentinelInformationEx()
        {
          ns1__ReportSentinelInformationEx = (_ns1__ReportSentinelInformationEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportSentinelInformationEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportSentinelInformationEx * SOAP_FMAC2 soap_instantiate___ns1__ReportSentinelInformationEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6276 */
#ifndef SOAP_TYPE___ns1__ReportSentinelInformation25
#define SOAP_TYPE___ns1__ReportSentinelInformation25 (317)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportSentinelInformation25 {
      public:
        /** Optional element 'ns1:ReportSentinelInformation25' of XSD type 'ns1:ReportSentinelInformation25' */
        _ns1__ReportSentinelInformation25 *ns1__ReportSentinelInformation25;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportSentinelInformation25 */
        int soap_type() const { return SOAP_TYPE___ns1__ReportSentinelInformation25; }
        /** Constructor with member initializations */
        __ns1__ReportSentinelInformation25()
        {
          ns1__ReportSentinelInformation25 = (_ns1__ReportSentinelInformation25 *)0;
        }
        /** Friend allocator used by soap_new___ns1__ReportSentinelInformation25(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ReportSentinelInformation25 * SOAP_FMAC2 soap_instantiate___ns1__ReportSentinelInformation25(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6346 */
#ifndef SOAP_TYPE___ns1__GetThirdPartyBlob
#define SOAP_TYPE___ns1__GetThirdPartyBlob (321)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetThirdPartyBlob {
      public:
        /** Optional element 'ns1:GetThirdPartyBlob' of XSD type 'ns1:GetThirdPartyBlob' */
        _ns1__GetThirdPartyBlob *ns1__GetThirdPartyBlob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetThirdPartyBlob */
        int soap_type() const { return SOAP_TYPE___ns1__GetThirdPartyBlob; }
        /** Constructor with member initializations */
        __ns1__GetThirdPartyBlob()
        {
          ns1__GetThirdPartyBlob = (_ns1__GetThirdPartyBlob *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetThirdPartyBlob(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetThirdPartyBlob * SOAP_FMAC2 soap_instantiate___ns1__GetThirdPartyBlob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6416 */
#ifndef SOAP_TYPE___ns1__SendBlobToThirdParty
#define SOAP_TYPE___ns1__SendBlobToThirdParty (325)
/* Wrapper: */
struct SOAP_CMAC __ns1__SendBlobToThirdParty {
      public:
        /** Optional element 'ns1:SendBlobToThirdParty' of XSD type 'ns1:SendBlobToThirdParty' */
        _ns1__SendBlobToThirdParty *ns1__SendBlobToThirdParty;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SendBlobToThirdParty */
        int soap_type() const { return SOAP_TYPE___ns1__SendBlobToThirdParty; }
        /** Constructor with member initializations */
        __ns1__SendBlobToThirdParty()
        {
          ns1__SendBlobToThirdParty = (_ns1__SendBlobToThirdParty *)0;
        }
        /** Friend allocator used by soap_new___ns1__SendBlobToThirdParty(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__SendBlobToThirdParty * SOAP_FMAC2 soap_instantiate___ns1__SendBlobToThirdParty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6486 */
#ifndef SOAP_TYPE___ns1__GetEventTriggerNotification
#define SOAP_TYPE___ns1__GetEventTriggerNotification (329)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetEventTriggerNotification {
      public:
        /** Optional element 'ns1:GetEventTriggerNotification' of XSD type 'ns1:GetEventTriggerNotification' */
        _ns1__GetEventTriggerNotification *ns1__GetEventTriggerNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetEventTriggerNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetEventTriggerNotification; }
        /** Constructor with member initializations */
        __ns1__GetEventTriggerNotification()
        {
          ns1__GetEventTriggerNotification = (_ns1__GetEventTriggerNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetEventTriggerNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetEventTriggerNotification * SOAP_FMAC2 soap_instantiate___ns1__GetEventTriggerNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6556 */
#ifndef SOAP_TYPE___ns1__GetCasinoChallengeTriggeredEventNotificationCustom
#define SOAP_TYPE___ns1__GetCasinoChallengeTriggeredEventNotificationCustom (333)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCasinoChallengeTriggeredEventNotificationCustom {
      public:
        /** Optional element 'ns1:GetCasinoChallengeTriggeredEventNotificationCustom' of XSD type 'ns1:GetCasinoChallengeTriggeredEventNotificationCustom' */
        _ns1__GetCasinoChallengeTriggeredEventNotificationCustom *ns1__GetCasinoChallengeTriggeredEventNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCasinoChallengeTriggeredEventNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetCasinoChallengeTriggeredEventNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetCasinoChallengeTriggeredEventNotificationCustom()
        {
          ns1__GetCasinoChallengeTriggeredEventNotificationCustom = (_ns1__GetCasinoChallengeTriggeredEventNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCasinoChallengeTriggeredEventNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6626 */
#ifndef SOAP_TYPE___ns1__GetCasinoChallangeIncrementNotification
#define SOAP_TYPE___ns1__GetCasinoChallangeIncrementNotification (337)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCasinoChallangeIncrementNotification {
      public:
        /** Optional element 'ns1:GetCasinoChallangeIncrementNotification' of XSD type 'ns1:GetCasinoChallangeIncrementNotification' */
        _ns1__GetCasinoChallangeIncrementNotification *ns1__GetCasinoChallangeIncrementNotification;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCasinoChallangeIncrementNotification */
        int soap_type() const { return SOAP_TYPE___ns1__GetCasinoChallangeIncrementNotification; }
        /** Constructor with member initializations */
        __ns1__GetCasinoChallangeIncrementNotification()
        {
          ns1__GetCasinoChallangeIncrementNotification = (_ns1__GetCasinoChallangeIncrementNotification *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCasinoChallangeIncrementNotification(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCasinoChallangeIncrementNotification * SOAP_FMAC2 soap_instantiate___ns1__GetCasinoChallangeIncrementNotification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6696 */
#ifndef SOAP_TYPE___ns1__GetCasinoChallangeEventEndNotificationCustom
#define SOAP_TYPE___ns1__GetCasinoChallangeEventEndNotificationCustom (341)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCasinoChallangeEventEndNotificationCustom {
      public:
        /** Optional element 'ns1:GetCasinoChallangeEventEndNotificationCustom' of XSD type 'ns1:GetCasinoChallangeEventEndNotificationCustom' */
        _ns1__GetCasinoChallangeEventEndNotificationCustom *ns1__GetCasinoChallangeEventEndNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCasinoChallangeEventEndNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetCasinoChallangeEventEndNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetCasinoChallangeEventEndNotificationCustom()
        {
          ns1__GetCasinoChallangeEventEndNotificationCustom = (_ns1__GetCasinoChallangeEventEndNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCasinoChallangeEventEndNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6766 */
#ifndef SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustom
#define SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustom (345)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCasinoChallengeAwardNotificationCustom {
      public:
        /** Optional element 'ns1:GetCasinoChallengeAwardNotificationCustom' of XSD type 'ns1:GetCasinoChallengeAwardNotificationCustom' */
        _ns1__GetCasinoChallengeAwardNotificationCustom *ns1__GetCasinoChallengeAwardNotificationCustom;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustom */
        int soap_type() const { return SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustom; }
        /** Constructor with member initializations */
        __ns1__GetCasinoChallengeAwardNotificationCustom()
        {
          ns1__GetCasinoChallengeAwardNotificationCustom = (_ns1__GetCasinoChallengeAwardNotificationCustom *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCasinoChallengeAwardNotificationCustom * SOAP_FMAC2 soap_instantiate___ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6836 */
#ifndef SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData
#define SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData (349)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData {
      public:
        /** Optional element 'ns1:GetCasinoChallengeAwardNotificationCustomWithMediaData' of XSD type 'ns1:GetCasinoChallengeAwardNotificationCustomWithMediaData' */
        _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData *ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData */
        int soap_type() const { return SOAP_TYPE___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData; }
        /** Constructor with member initializations */
        __ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData()
        {
          ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData = (_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData * SOAP_FMAC2 soap_instantiate___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* cacheservice.h:6906 */
#ifndef SOAP_TYPE___ns1__GetCacheMethodList
#define SOAP_TYPE___ns1__GetCacheMethodList (353)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCacheMethodList {
      public:
        /** Optional element 'ns1:GetCacheMethodList' of XSD type 'ns1:GetCacheMethodList' */
        _ns1__GetCacheMethodList *ns1__GetCacheMethodList;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCacheMethodList */
        int soap_type() const { return SOAP_TYPE___ns1__GetCacheMethodList; }
        /** Constructor with member initializations */
        __ns1__GetCacheMethodList()
        {
          ns1__GetCacheMethodList = (_ns1__GetCacheMethodList *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetCacheMethodList(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetCacheMethodList * SOAP_FMAC2 soap_instantiate___ns1__GetCacheMethodList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (355)
/* complex XSD type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XSD type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        int soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp()
        {
          wsu__Id = (char *)0;
          Created = (char *)0;
          Expires = (char *)0;
        }
        /** Friend allocator used by soap_new__wsu__Timestamp(struct soap*, int) */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:57 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (356)
/* simple XSD type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        int soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString()
        {
          __item = (char *)0;
          EncodingType = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_wsse__EncodedString(struct soap*, int) */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:128 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (358)
/* complex XSD type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XSD type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XSD type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XSD type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        int soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken()
        {
          Username = (char *)0;
          Password = (struct _wsse__Password *)0;
          Nonce = (struct wsse__EncodedString *)0;
          wsu__Created = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__UsernameToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:139 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (362)
/* simple XSD type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        int soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__BinarySecurityToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:149 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (363)
/* complex XSD type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        int soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference()
        {
          URI = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Reference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:157 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (364)
/* complex XSD type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        int soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded()
        {
          wsu__Id = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Embedded(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:166 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (365)
/* simple XSD type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        int soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__KeyIdentifier(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (366)
/* complex XSD type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XSD type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XSD type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XSD type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XSD type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XSD type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        int soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference()
        {
          Reference = (struct _wsse__Reference *)0;
          KeyIdentifier = (struct _wsse__KeyIdentifier *)0;
          Embedded = (struct _wsse__Embedded *)0;
          ds__X509Data = (struct ds__X509DataType *)0;
          wsu__Id = (char *)0;
          wsc__Instance = (char *)0;
          Usage = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__SecurityTokenReference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (373)
/* complex XSD type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XSD type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XSD type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType()
        {
          SignedInfo = (struct ds__SignedInfoType *)0;
          SignatureValue = (char *)0;
          KeyInfo = (struct ds__KeyInfoType *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (383)
/* complex XSD type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XSD type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        int soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces()
        {
          PrefixList = (char *)0;
        }
        /** Friend allocator used by soap_new__c14n__InclusiveNamespaces(struct soap*, int) */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:73 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (384)
/* complex XSD type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        int soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType()
        {
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
          __any = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__TransformType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (376)
/* complex XSD type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'ds:KeyName' of XSD type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XSD type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XSD type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        int soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType()
        {
          KeyName = (char *)0;
          KeyValue = (struct ds__KeyValueType *)0;
          RetrievalMethod = (struct ds__RetrievalMethodType *)0;
          X509Data = (struct ds__X509DataType *)0;
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (374)
/* complex XSD type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XSD type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XSD type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XSD type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        int soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType()
        {
          CanonicalizationMethod = (struct ds__CanonicalizationMethodType *)0;
          SignatureMethod = (struct ds__SignatureMethodType *)0;
          __sizeReference = 0;
          Reference = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignedInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:59 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (379)
/* complex XSD type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        int soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType()
        {
          Algorithm = (char *)0;
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
        }
        /** Friend allocator used by soap_new_ds__CanonicalizationMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:62 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (380)
/* complex XSD type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XSD type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType()
        {
          HMACOutputLength = (int *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:65 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (381)
/* complex XSD type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XSD type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        int soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType()
        {
          Transforms = (struct ds__TransformsType *)0;
          DigestMethod = (struct ds__DigestMethodType *)0;
          DigestValue = (char *)0;
          Id = (char *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:68 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (382)
/* complex XSD type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XSD type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        int soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType()
        {
          __sizeTransform = 0;
          Transform = NULL;
        }
        /** Friend allocator used by soap_new_ds__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:79 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (387)
/* complex XSD type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        int soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType()
        {
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DigestMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:84 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (388)
/* complex XSD type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XSD type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XSD type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType()
        {
          DSAKeyValue = (struct ds__DSAKeyValueType *)0;
          RSAKeyValue = (struct ds__RSAKeyValueType *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:85 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (390)
/* complex XSD type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        int soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType()
        {
          Transforms = (struct ds__TransformsType *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RetrievalMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:179 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (370)
/* complex XSD type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XSD type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XSD type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XSD type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XSD type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XSD type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        int soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType()
        {
          X509IssuerSerial = (struct ds__X509IssuerSerialType *)0;
          X509SKI = (char *)0;
          X509SubjectName = (char *)0;
          X509Certificate = (char *)0;
          X509CRL = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509DataType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:102 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (394)
/* complex XSD type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XSD type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XSD type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        int soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType()
        {
          X509IssuerName = (char *)0;
          X509SerialNumber = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509IssuerSerialType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:123 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (395)
/* complex XSD type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XSD type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XSD type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XSD type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XSD type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XSD type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XSD type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XSD type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType()
        {
          G = (char *)0;
          Y = (char *)0;
          J = (char *)0;
          P = (char *)0;
          Q = (char *)0;
          Seed = (char *)0;
          PgenCounter = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:126 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (396)
/* complex XSD type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XSD type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XSD type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType()
        {
          Modulus = (char *)0;
          Exponent = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (417)
/* complex XSD type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XSD type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType()
        {
          Target = (char *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (407)
/* complex XSD type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (408)
/* complex XSD type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XSD type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XSD type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType()
        {
          KeySize = (int *)0;
          OAEPparams = (char *)0;
          Algorithm = (char *)0;
          ds__DigestMethod = (struct ds__DigestMethodType *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (409)
/* complex XSD type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XSD type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XSD type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType()
        {
          CipherValue = (char *)0;
          CipherReference = (struct xenc__CipherReferenceType *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (410)
/* complex XSD type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XSD type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType()
        {
          Transforms = (struct xenc__TransformsType *)0;
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (411)
/* complex XSD type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XSD type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        int soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType()
        {
        }
        /** Friend allocator used by soap_new_xenc__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (414)
/* complex XSD type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XSD type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType()
        {
          KA_Nonce = (char *)0;
          OriginatorKeyInfo = (struct ds__KeyInfoType *)0;
          RecipientKeyInfo = (struct ds__KeyInfoType *)0;
          Algorithm = (char *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__AgreementMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (415)
/* complex XSD type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType()
        {
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (416)
/* complex XSD type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XSD type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType()
        {
          __sizeEncryptionProperty = 0;
          EncryptionProperty = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (426)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        int soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList()
        {
          DataReference = (struct xenc__ReferenceType *)0;
          KeyReference = (struct xenc__ReferenceType *)0;
        }
        /** Friend allocator used by soap_new___xenc__union_ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (418)
/* complex XSD type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XSD type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        int soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList()
        {
          __size_ReferenceList = 0;
          __union_ReferenceList = NULL;
        }
        /** Friend allocator used by soap_new__xenc__ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (412)
/* complex XSD type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (413)
/* complex XSD type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XSD type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
          ReferenceList = (struct _xenc__ReferenceList *)0;
          CarriedKeyName = (char *)0;
          Recipient = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedKeyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (432)
/* complex XSD type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XSD type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XSD type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType()
        {
          wsu__Id = (char *)0;
          Identifier = (char *)0;
          Instance = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__SecurityContextTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (437)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (436)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XSD type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        int soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence()
        {
          __union_DerivedKeyTokenType = -1;
          Length = (ULONG64 *)0;
        }
        /** Friend allocator used by soap_new___wsc__DerivedKeyTokenType_sequence(struct soap*, int) */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (433)
/* complex XSD type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XSD type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XSD type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XSD type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType()
        {
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Properties = (struct wsc__PropertiesType *)0;
          __DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)0;
          Label = (char *)0;
          Nonce = (char *)0;
          wsu__Id = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__DerivedKeyTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (434)
/* complex XSD type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        int soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType()
        {
        }
        /** Friend allocator used by soap_new_wsc__PropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:145 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (463)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XSD type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XSD type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XSD type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XSD type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XSD type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        int soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType()
        {
          saml1__Statement = (struct saml1__StatementAbstractType *)0;
          saml1__SubjectStatement = (struct saml1__SubjectStatementAbstractType *)0;
          saml1__AuthenticationStatement = (struct saml1__AuthenticationStatementType *)0;
          saml1__AuthorizationDecisionStatement = (struct saml1__AuthorizationDecisionStatementType *)0;
          saml1__AttributeStatement = (struct saml1__AttributeStatementType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:61 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (440)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XSD type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XSD type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XSD type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XSD type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XSD type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XSD type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Required attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        int soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType()
        {
          saml1__Conditions = (struct saml1__ConditionsType *)0;
          saml1__Advice = (struct saml1__AdviceType *)0;
          __size_AssertionType = 0;
          __union_AssertionType = NULL;
          ds__Signature = (struct ds__SignatureType *)0;
          MajorVersion = (char *)0;
          MinorVersion = (char *)0;
          AssertionID = (char *)0;
          Issuer = (char *)0;
          IssueInstant = (time_t)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:187 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (471)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XSD type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XSD type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XSD type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        int soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType()
        {
          saml1__AudienceRestrictionCondition = (struct saml1__AudienceRestrictionConditionType *)0;
          saml1__DoNotCacheCondition = (struct saml1__DoNotCacheConditionType *)0;
          saml1__Condition = (struct saml1__ConditionAbstractType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:63 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (441)
/* complex XSD type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        int soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType()
        {
          __size_ConditionsType = 0;
          __union_ConditionsType = NULL;
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml1__ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:65 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (442)
/* complex XSD type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml1__ConditionAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:227 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (477)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        int soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType()
        {
          saml1__AssertionIDReference = (char *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:71 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (445)
/* complex XSD type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        int soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType()
        {
          __size_AdviceType = 0;
          __union_AdviceType = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:73 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (446)
/* complex XSD type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml1__StatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:77 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (448)
/* complex XSD type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XSD type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XSD type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType()
        {
          saml1__NameIdentifier = (struct saml1__NameIdentifierType *)0;
          saml1__SubjectConfirmation = (struct saml1__SubjectConfirmationType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:81 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (450)
/* complex XSD type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XSD type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XSD type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType()
        {
          __sizeConfirmationMethod = 0;
          saml1__ConfirmationMethod = NULL;
          saml1__SubjectConfirmationData = (char *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectConfirmationType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:85 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (452)
/* complex XSD type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XSD type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XSD type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType()
        {
          IPAddress = (char *)0;
          DNSAddress = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectLocalityType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:87 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (453)
/* complex XSD type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XSD type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XSD type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XSD type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType()
        {
          AuthorityKind = (char *)0;
          Location = (char *)0;
          Binding = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthorityBindingType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:344 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (482)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        int soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType()
        {
          saml1__AssertionIDReference = (char *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
        }
        /** Friend allocator used by soap_new___saml1__union_EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:93 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (456)
/* complex XSD type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        int soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType()
        {
          __size_EvidenceType = 0;
          __union_EvidenceType = NULL;
        }
        /** Friend allocator used by soap_new_saml1__EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:97 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (458)
/* complex XSD type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType()
        {
          AttributeName = (char *)0;
          AttributeNamespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__AttributeDesignatorType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:67 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (443)
/* complex XSD type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XSD type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        int soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType()
        {
          __sizeAudience = 0;
          saml1__Audience = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AudienceRestrictionConditionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:69 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (444)
/* complex XSD type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        int soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType()
        {
        }
        /** Friend allocator used by soap_new_saml1__DoNotCacheConditionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:75 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (447)
/* complex XSD type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
        }
        /** Friend allocator used by soap_new_saml1__SubjectStatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:79 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (449)
/* simple XSD type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        int soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType()
        {
          __item = (char *)0;
          NameQualifier = (char *)0;
          Format = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__NameIdentifierType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:91 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (455)
/* simple XSD type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        int soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType()
        {
          __item = (char *)0;
          Namespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml1__ActionType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:99 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (459)
/* complex XSD type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType()
        {
          AttributeName = (char *)0;
          AttributeNamespace = (char *)0;
          __sizeAttributeValue = 0;
          saml1__AttributeValue = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AttributeType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:83 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (451)
/* complex XSD type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XSD type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XSD type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XSD type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XSD type 'xsd:dateTime' */
        time_t AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          saml1__SubjectLocality = (struct saml1__SubjectLocalityType *)0;
          __sizeAuthorityBinding = 0;
          saml1__AuthorityBinding = NULL;
          AuthenticationMethod = (char *)0;
          AuthenticationInstant = (time_t)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthenticationStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:89 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (454)
/* complex XSD type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XSD type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XSD type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          __sizeAction = 0;
          saml1__Action = NULL;
          saml1__Evidence = (struct saml1__EvidenceType *)0;
          Resource = (char *)0;
          Decision = (enum saml1__DecisionType)0;
        }
        /** Friend allocator used by soap_new_saml1__AuthorizationDecisionStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:95 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (457)
/* complex XSD type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XSD type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        int soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType()
        {
          saml1__Subject = (struct saml1__SubjectType *)0;
          __sizeAttribute = 0;
          saml1__Attribute = NULL;
        }
        /** Friend allocator used by soap_new_saml1__AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:61 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (491)
/* complex XSD type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType()
        {
          NameQualifier = (char *)0;
          SPNameQualifier = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__BaseIDAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:65 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (493)
/* complex XSD type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XSD type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        int soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType()
        {
          __sizexenc__EncryptedKey = 0;
          xenc__EncryptedKey = NULL;
        }
        /** Friend allocator used by soap_new_saml2__EncryptedElementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:193 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (521)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XSD type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XSD type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XSD type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XSD type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType()
        {
          saml2__Statement = (struct saml2__StatementAbstractType *)0;
          saml2__AuthnStatement = (struct saml2__AuthnStatementType *)0;
          saml2__AuthzDecisionStatement = (struct saml2__AuthzDecisionStatementType *)0;
          saml2__AttributeStatement = (struct saml2__AttributeStatementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:67 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (494)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XSD type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XSD type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XSD type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XSD type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XSD type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Required attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        int soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType()
        {
          saml2__Issuer = (struct saml2__NameIDType *)0;
          ds__Signature = (struct ds__SignatureType *)0;
          saml2__Subject = (struct saml2__SubjectType *)0;
          saml2__Conditions = (struct saml2__ConditionsType *)0;
          saml2__Advice = (struct saml2__AdviceType *)0;
          __size_AssertionType = 0;
          __union_AssertionType = NULL;
          Version = (char *)0;
          ID = (char *)0;
          IssueInstant = (time_t)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__AssertionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:69 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (495)
/* complex XSD type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XSD type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType()
        {
          saml2__BaseID = (struct saml2__BaseIDAbstractType *)0;
          saml2__NameID = (struct saml2__NameIDType *)0;
          saml2__EncryptedID = (struct saml2__EncryptedElementType *)0;
          __sizeSubjectConfirmation = 0;
          saml2__SubjectConfirmation = NULL;
        }
        /** Friend allocator used by soap_new_saml2__SubjectType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:71 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (496)
/* complex XSD type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XSD type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XSD type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType()
        {
          saml2__BaseID = (struct saml2__BaseIDAbstractType *)0;
          saml2__NameID = (struct saml2__NameIDType *)0;
          saml2__EncryptedID = (struct saml2__EncryptedElementType *)0;
          saml2__SubjectConfirmationData = (struct saml2__SubjectConfirmationDataType *)0;
          Method = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectConfirmationType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:284 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (531)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XSD type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XSD type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XSD type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XSD type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        int soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType()
        {
          saml2__Condition = (struct saml2__ConditionAbstractType *)0;
          saml2__AudienceRestriction = (struct saml2__AudienceRestrictionType *)0;
          saml2__OneTimeUse = (struct saml2__OneTimeUseType *)0;
          saml2__ProxyRestriction = (struct saml2__ProxyRestrictionType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:77 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (499)
/* complex XSD type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        int soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType()
        {
          __size_ConditionsType = 0;
          __union_ConditionsType = NULL;
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml2__ConditionsType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:79 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (500)
/* complex XSD type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml2__ConditionAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:326 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (537)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType()
        {
          saml2__AssertionIDRef = (char *)0;
          saml2__AssertionURIRef = (char *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          saml2__EncryptedAssertion = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:87 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (504)
/* complex XSD type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        int soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType()
        {
          __size_AdviceType = 0;
          __union_AdviceType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AdviceType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:89 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (505)
/* complex XSD type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        int soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType()
        {
        }
        /** Friend allocator used by soap_new_saml2__StatementAbstractType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:93 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (507)
/* complex XSD type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XSD type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType()
        {
          Address = (char *)0;
          DNSName = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectLocalityType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:95 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (508)
/* complex XSD type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XSD type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XSD type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType()
        {
          saml2__AuthnContextClassRef = (char *)0;
          saml2__AuthnContextDecl = (char *)0;
          saml2__AuthnContextDeclRef = (char *)0;
          __sizeAuthenticatingAuthority = 0;
          saml2__AuthenticatingAuthority = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AuthnContextType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:421 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (540)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        int soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType()
        {
          saml2__AssertionIDRef = (char *)0;
          saml2__AssertionURIRef = (char *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          saml2__EncryptedAssertion = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:101 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (511)
/* complex XSD type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        int soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType()
        {
          __size_EvidenceType = 0;
          __union_EvidenceType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__EvidenceType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:105 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (513)
/* complex XSD type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XSD type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XSD type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XSD type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        int soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType()
        {
          __sizeAttributeValue = 0;
          saml2__AttributeValue = NULL;
          Name = (char *)0;
          NameFormat = (char *)0;
          FriendlyName = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__AttributeType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:63 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (492)
/* simple XSD type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XSD type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        int soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType()
        {
          __item = (char *)0;
          Format = (char *)0;
          SPProvidedID = (char *)0;
          NameQualifier = (char *)0;
          SPNameQualifier = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__NameIDType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:73 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (497)
/* complex XSD type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XSD type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        int soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType()
        {
          NotBefore = (time_t *)0;
          NotOnOrAfter = (time_t *)0;
          Recipient = (char *)0;
          InResponseTo = (char *)0;
          Address = (char *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__SubjectConfirmationDataType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:81 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (501)
/* complex XSD type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        int soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType()
        {
          __sizeAudience = 0;
          saml2__Audience = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AudienceRestrictionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:83 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (502)
/* complex XSD type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        int soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType()
        {
        }
        /** Friend allocator used by soap_new_saml2__OneTimeUseType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:85 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (503)
/* complex XSD type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XSD type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        int soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType()
        {
          __sizeAudience = 0;
          saml2__Audience = NULL;
          Count = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__ProxyRestrictionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:91 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (506)
/* complex XSD type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XSD type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XSD type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XSD type 'xsd:dateTime' */
        time_t AuthnInstant;
        /** Optional attribute 'SessionIndex' of XSD type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType()
        {
          saml2__SubjectLocality = (struct saml2__SubjectLocalityType *)0;
          saml2__AuthnContext = (struct saml2__AuthnContextType *)0;
          AuthnInstant = (time_t)0;
          SessionIndex = (char *)0;
          SessionNotOnOrAfter = (time_t *)0;
        }
        /** Friend allocator used by soap_new_saml2__AuthnStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:97 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (509)
/* complex XSD type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XSD type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XSD type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType()
        {
          __sizeAction = 0;
          saml2__Action = NULL;
          saml2__Evidence = (struct saml2__EvidenceType *)0;
          Resource = (char *)0;
          Decision = (enum saml2__DecisionType)0;
        }
        /** Friend allocator used by soap_new_saml2__AuthzDecisionStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:99 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (510)
/* simple XSD type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        int soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType()
        {
          __item = (char *)0;
          Namespace = (char *)0;
        }
        /** Friend allocator used by soap_new_saml2__ActionType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:653 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (546)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XSD type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        int soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType()
        {
          saml2__Attribute = (struct saml2__AttributeType *)0;
          saml2__EncryptedAttribute = (struct saml2__EncryptedElementType *)0;
        }
        /** Friend allocator used by soap_new___saml2__union_AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:103 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (512)
/* complex XSD type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XSD type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        int soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType()
        {
          __size_AttributeStatementType = 0;
          __union_AttributeStatementType = NULL;
        }
        /** Friend allocator used by soap_new_saml2__AttributeStatementType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:75 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (498)
/* complex XSD type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XSD type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        int soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType()
        {
          __sizeds__KeyInfo = 0;
          ds__KeyInfo = NULL;
        }
        /** Friend allocator used by soap_new_saml2__KeyInfoConfirmationDataType(struct soap*, int) */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:193 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (550)
/* complex XSD type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XSD type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XSD type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XSD type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XSD type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XSD type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XSD type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XSD type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        int soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security()
        {
          wsu__Timestamp = (struct _wsu__Timestamp *)0;
          UsernameToken = (struct _wsse__UsernameToken *)0;
          BinarySecurityToken = (struct _wsse__BinarySecurityToken *)0;
          xenc__EncryptedKey = (struct xenc__EncryptedKeyType *)0;
          xenc__ReferenceList = (struct _xenc__ReferenceList *)0;
          wsc__SecurityContextToken = (struct wsc__SecurityContextTokenType *)0;
          ds__Signature = (struct ds__SignatureType *)0;
          saml1__Assertion = (struct saml1__AssertionType *)0;
          saml2__Assertion = (struct saml2__AssertionType *)0;
          SOAP_ENV__actor = (char *)0;
          SOAP_ENV__role = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Security(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:129 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (359)
/* simple XSD type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        int soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password()
        {
          __item = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Password(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:225 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (556)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
          wsse__Security = (struct _wsse__Security *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* cacheservice.h:8462 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (558)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* cacheservice.h:8462 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (560)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* cacheservice.h:8462 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (563)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* cacheservice.h:8462 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (564)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* cacheservice.h:122 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* cacheservice.h:122 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* cacheservice.h:158 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (13)
typedef char xsd__byte;
#endif

/* cacheservice.h:161 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (14)
typedef unsigned char xsd__unsignedByte;
#endif

/* cacheservice.h:164 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (15)
typedef char *xsd__ID;
#endif

/* cacheservice.h:174 */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (17)
typedef char *xsd__IDREF;
#endif

/* cacheservice.h:191 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (20)
typedef char *xsd__anyURI;
#endif

/* cacheservice.h:229 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (28)
typedef char *xsd__decimal;
#endif

/* cacheservice.h:246 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (32)
typedef char *xsd__duration;
#endif

/* cacheservice.h:679 */
#ifndef SOAP_TYPE_ns4__char
#define SOAP_TYPE_ns4__char (148)
typedef int ns4__char;
#endif

/* cacheservice.h:692 */
#ifndef SOAP_TYPE_ns4__duration
#define SOAP_TYPE_ns4__duration (150)
typedef char *ns4__duration;
#endif

/* cacheservice.h:704 */
#ifndef SOAP_TYPE_ns4__guid
#define SOAP_TYPE_ns4__guid (152)
typedef char *ns4__guid;
#endif

/* ds.h:44 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (372)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (378)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:76 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (386)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (393)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (430)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (13)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (40)
#endif

/* ns4__char has binding name 'ns4__char' for type 'ns4:char' */
#ifndef SOAP_TYPE_ns4__char
#define SOAP_TYPE_ns4__char (148)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (38)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (35)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (31)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (14)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (11)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (47)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (10)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (45)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (27)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (514)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (460)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (431)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (357)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (354)
#endif

/* enum ns3__EventData_x002eCustomMessageJustificationType has binding name 'ns3__EventData_x002eCustomMessageJustificationType' for type 'ns3:EventData.CustomMessageJustificationType' */
#ifndef SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType
#define SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType (146)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (24)
#endif

/* _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring has binding name '_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring' for type '' */
#ifndef SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE__ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (166)
#endif

/* ns4__guid__ has binding name 'ns4__guid__' for type 'ns4:guid' */
#ifndef SOAP_TYPE_ns4__guid__
#define SOAP_TYPE_ns4__guid__ (153)
#endif

/* ns4__duration__ has binding name 'ns4__duration__' for type 'ns4:duration' */
#ifndef SOAP_TYPE_ns4__duration__
#define SOAP_TYPE_ns4__duration__ (151)
#endif

/* ns4__char__ has binding name 'ns4__char__' for type 'ns4:char' */
#ifndef SOAP_TYPE_ns4__char__
#define SOAP_TYPE_ns4__char__ (149)
#endif

/* ns3__EventData_x002eCustomMessageJustificationType_ has binding name 'ns3__EventData_x002eCustomMessageJustificationType_' for type 'ns3:EventData.CustomMessageJustificationType' */
#ifndef SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_
#define SOAP_TYPE_ns3__EventData_x002eCustomMessageJustificationType_ (147)
#endif

/* ns3__CustomMessageLine has binding name 'ns3__CustomMessageLine' for type 'ns3:CustomMessageLine' */
#ifndef SOAP_TYPE_ns3__CustomMessageLine
#define SOAP_TYPE_ns3__CustomMessageLine (145)
#endif

/* ns3__ArrayOfCustomMessageLine has binding name 'ns3__ArrayOfCustomMessageLine' for type 'ns3:ArrayOfCustomMessageLine' */
#ifndef SOAP_TYPE_ns3__ArrayOfCustomMessageLine
#define SOAP_TYPE_ns3__ArrayOfCustomMessageLine (144)
#endif

/* ns3__CustomMessageScreen has binding name 'ns3__CustomMessageScreen' for type 'ns3:CustomMessageScreen' */
#ifndef SOAP_TYPE_ns3__CustomMessageScreen
#define SOAP_TYPE_ns3__CustomMessageScreen (143)
#endif

/* ns2__ArrayOfstring has binding name 'ns2__ArrayOfstring' for type 'ns2:ArrayOfstring' */
#ifndef SOAP_TYPE_ns2__ArrayOfstring
#define SOAP_TYPE_ns2__ArrayOfstring (142)
#endif

/* ns2__ArrayOfKeyValueOfstringstring has binding name 'ns2__ArrayOfKeyValueOfstringstring' for type 'ns2:ArrayOfKeyValueOfstringstring' */
#ifndef SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_ns2__ArrayOfKeyValueOfstringstring (141)
#endif

/* ns2__ArrayOflong has binding name 'ns2__ArrayOflong' for type 'ns2:ArrayOflong' */
#ifndef SOAP_TYPE_ns2__ArrayOflong
#define SOAP_TYPE_ns2__ArrayOflong (140)
#endif

/* ns2__ArrayOfint has binding name 'ns2__ArrayOfint' for type 'ns2:ArrayOfint' */
#ifndef SOAP_TYPE_ns2__ArrayOfint
#define SOAP_TYPE_ns2__ArrayOfint (139)
#endif

/* ns2__ArrayOfbase64Binary has binding name 'ns2__ArrayOfbase64Binary' for type 'ns2:ArrayOfbase64Binary' */
#ifndef SOAP_TYPE_ns2__ArrayOfbase64Binary
#define SOAP_TYPE_ns2__ArrayOfbase64Binary (138)
#endif

/* _ns1__GetCacheMethodListResponse has binding name '_ns1__GetCacheMethodListResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCacheMethodListResponse
#define SOAP_TYPE__ns1__GetCacheMethodListResponse (137)
#endif

/* _ns1__GetCacheMethodList has binding name '_ns1__GetCacheMethodList' for type '' */
#ifndef SOAP_TYPE__ns1__GetCacheMethodList
#define SOAP_TYPE__ns1__GetCacheMethodList (136)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse has binding name '_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse (135)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData has binding name '_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData (134)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustomResponse has binding name '_ns1__GetCasinoChallengeAwardNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustomResponse (133)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustom has binding name '_ns1__GetCasinoChallengeAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallengeAwardNotificationCustom (132)
#endif

/* _ns1__GetCasinoChallangeEventEndNotificationCustomResponse has binding name '_ns1__GetCasinoChallangeEventEndNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustomResponse (131)
#endif

/* _ns1__GetCasinoChallangeEventEndNotificationCustom has binding name '_ns1__GetCasinoChallangeEventEndNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallangeEventEndNotificationCustom (130)
#endif

/* _ns1__GetCasinoChallangeIncrementNotificationResponse has binding name '_ns1__GetCasinoChallangeIncrementNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse
#define SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotificationResponse (129)
#endif

/* _ns1__GetCasinoChallangeIncrementNotification has binding name '_ns1__GetCasinoChallangeIncrementNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification
#define SOAP_TYPE__ns1__GetCasinoChallangeIncrementNotification (128)
#endif

/* _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse has binding name '_ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse (127)
#endif

/* _ns1__GetCasinoChallengeTriggeredEventNotificationCustom has binding name '_ns1__GetCasinoChallengeTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetCasinoChallengeTriggeredEventNotificationCustom (126)
#endif

/* _ns1__GetEventTriggerNotificationResponse has binding name '_ns1__GetEventTriggerNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventTriggerNotificationResponse
#define SOAP_TYPE__ns1__GetEventTriggerNotificationResponse (125)
#endif

/* _ns1__GetEventTriggerNotification has binding name '_ns1__GetEventTriggerNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventTriggerNotification
#define SOAP_TYPE__ns1__GetEventTriggerNotification (124)
#endif

/* _ns1__SendBlobToThirdPartyResponse has binding name '_ns1__SendBlobToThirdPartyResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SendBlobToThirdPartyResponse
#define SOAP_TYPE__ns1__SendBlobToThirdPartyResponse (123)
#endif

/* _ns1__SendBlobToThirdParty has binding name '_ns1__SendBlobToThirdParty' for type '' */
#ifndef SOAP_TYPE__ns1__SendBlobToThirdParty
#define SOAP_TYPE__ns1__SendBlobToThirdParty (122)
#endif

/* _ns1__GetThirdPartyBlobResponse has binding name '_ns1__GetThirdPartyBlobResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetThirdPartyBlobResponse
#define SOAP_TYPE__ns1__GetThirdPartyBlobResponse (121)
#endif

/* _ns1__GetThirdPartyBlob has binding name '_ns1__GetThirdPartyBlob' for type '' */
#ifndef SOAP_TYPE__ns1__GetThirdPartyBlob
#define SOAP_TYPE__ns1__GetThirdPartyBlob (120)
#endif

/* _ns1__ReportSentinelInformation25Response has binding name '_ns1__ReportSentinelInformation25Response' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation25Response
#define SOAP_TYPE__ns1__ReportSentinelInformation25Response (119)
#endif

/* _ns1__ReportSentinelInformation25 has binding name '_ns1__ReportSentinelInformation25' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation25
#define SOAP_TYPE__ns1__ReportSentinelInformation25 (118)
#endif

/* _ns1__ReportSentinelInformationExResponse has binding name '_ns1__ReportSentinelInformationExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationExResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationExResponse (117)
#endif

/* _ns1__ReportSentinelInformationEx has binding name '_ns1__ReportSentinelInformationEx' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationEx
#define SOAP_TYPE__ns1__ReportSentinelInformationEx (116)
#endif

/* _ns1__ReportSentinelInformationWithOrientationResponse has binding name '_ns1__ReportSentinelInformationWithOrientationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationWithOrientationResponse (115)
#endif

/* _ns1__ReportSentinelInformationWithOrientation has binding name '_ns1__ReportSentinelInformationWithOrientation' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation
#define SOAP_TYPE__ns1__ReportSentinelInformationWithOrientation (114)
#endif

/* _ns1__ReportSentinelInformationResponse has binding name '_ns1__ReportSentinelInformationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformationResponse
#define SOAP_TYPE__ns1__ReportSentinelInformationResponse (113)
#endif

/* _ns1__ReportSentinelInformation has binding name '_ns1__ReportSentinelInformation' for type '' */
#ifndef SOAP_TYPE__ns1__ReportSentinelInformation
#define SOAP_TYPE__ns1__ReportSentinelInformation (112)
#endif

/* _ns1__ReportStatusResponse has binding name '_ns1__ReportStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportStatusResponse
#define SOAP_TYPE__ns1__ReportStatusResponse (111)
#endif

/* _ns1__ReportStatus has binding name '_ns1__ReportStatus' for type '' */
#ifndef SOAP_TYPE__ns1__ReportStatus
#define SOAP_TYPE__ns1__ReportStatus (110)
#endif

/* _ns1__AcknowledgeExternalPaidResponse has binding name '_ns1__AcknowledgeExternalPaidResponse' for type '' */
#ifndef SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse
#define SOAP_TYPE__ns1__AcknowledgeExternalPaidResponse (109)
#endif

/* _ns1__AcknowledgeExternalPaid has binding name '_ns1__AcknowledgeExternalPaid' for type '' */
#ifndef SOAP_TYPE__ns1__AcknowledgeExternalPaid
#define SOAP_TYPE__ns1__AcknowledgeExternalPaid (108)
#endif

/* _ns1__ReportGameStartResponse has binding name '_ns1__ReportGameStartResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportGameStartResponse
#define SOAP_TYPE__ns1__ReportGameStartResponse (107)
#endif

/* _ns1__ReportGameStart has binding name '_ns1__ReportGameStart' for type '' */
#ifndef SOAP_TYPE__ns1__ReportGameStart
#define SOAP_TYPE__ns1__ReportGameStart (106)
#endif

/* _ns1__ReportEventMeterDeltasResponse has binding name '_ns1__ReportEventMeterDeltasResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportEventMeterDeltasResponse
#define SOAP_TYPE__ns1__ReportEventMeterDeltasResponse (105)
#endif

/* _ns1__ReportEventMeterDeltas has binding name '_ns1__ReportEventMeterDeltas' for type '' */
#ifndef SOAP_TYPE__ns1__ReportEventMeterDeltas
#define SOAP_TYPE__ns1__ReportEventMeterDeltas (104)
#endif

/* _ns1__InTriggeredEventTriggerResponse has binding name '_ns1__InTriggeredEventTriggerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InTriggeredEventTriggerResponse
#define SOAP_TYPE__ns1__InTriggeredEventTriggerResponse (103)
#endif

/* _ns1__InTriggeredEventTrigger has binding name '_ns1__InTriggeredEventTrigger' for type '' */
#ifndef SOAP_TYPE__ns1__InTriggeredEventTrigger
#define SOAP_TYPE__ns1__InTriggeredEventTrigger (102)
#endif

/* _ns1__InEventTriggerResponse has binding name '_ns1__InEventTriggerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__InEventTriggerResponse
#define SOAP_TYPE__ns1__InEventTriggerResponse (101)
#endif

/* _ns1__InEventTrigger has binding name '_ns1__InEventTrigger' for type '' */
#ifndef SOAP_TYPE__ns1__InEventTrigger
#define SOAP_TYPE__ns1__InEventTrigger (100)
#endif

/* _ns1__GetEventXMLFileResponse has binding name '_ns1__GetEventXMLFileResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventXMLFileResponse
#define SOAP_TYPE__ns1__GetEventXMLFileResponse (99)
#endif

/* _ns1__GetEventXMLFile has binding name '_ns1__GetEventXMLFile' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventXMLFile
#define SOAP_TYPE__ns1__GetEventXMLFile (98)
#endif

/* _ns1__GetConfigExResponse has binding name '_ns1__GetConfigExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetConfigExResponse
#define SOAP_TYPE__ns1__GetConfigExResponse (97)
#endif

/* _ns1__GetConfigEx has binding name '_ns1__GetConfigEx' for type '' */
#ifndef SOAP_TYPE__ns1__GetConfigEx
#define SOAP_TYPE__ns1__GetConfigEx (96)
#endif

/* _ns1__GetConfigResponse has binding name '_ns1__GetConfigResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetConfigResponse
#define SOAP_TYPE__ns1__GetConfigResponse (95)
#endif

/* _ns1__GetConfig has binding name '_ns1__GetConfig' for type '' */
#ifndef SOAP_TYPE__ns1__GetConfig
#define SOAP_TYPE__ns1__GetConfig (94)
#endif

/* _ns1__GetFileInformationResponse has binding name '_ns1__GetFileInformationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFileInformationResponse
#define SOAP_TYPE__ns1__GetFileInformationResponse (93)
#endif

/* _ns1__GetFileInformation has binding name '_ns1__GetFileInformation' for type '' */
#ifndef SOAP_TYPE__ns1__GetFileInformation
#define SOAP_TYPE__ns1__GetFileInformation (92)
#endif

/* _ns1__GetFlashUdpCompleteAnnouncementResponse has binding name '_ns1__GetFlashUdpCompleteAnnouncementResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse
#define SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncementResponse (91)
#endif

/* _ns1__GetFlashUdpCompleteAnnouncement has binding name '_ns1__GetFlashUdpCompleteAnnouncement' for type '' */
#ifndef SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement
#define SOAP_TYPE__ns1__GetFlashUdpCompleteAnnouncement (90)
#endif

/* _ns1__GetFlashStartAnnouncementResponse has binding name '_ns1__GetFlashStartAnnouncementResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse
#define SOAP_TYPE__ns1__GetFlashStartAnnouncementResponse (89)
#endif

/* _ns1__GetFlashStartAnnouncement has binding name '_ns1__GetFlashStartAnnouncement' for type '' */
#ifndef SOAP_TYPE__ns1__GetFlashStartAnnouncement
#define SOAP_TYPE__ns1__GetFlashStartAnnouncement (88)
#endif

/* _ns1__RequestNonCardedEventsResponse has binding name '_ns1__RequestNonCardedEventsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RequestNonCardedEventsResponse
#define SOAP_TYPE__ns1__RequestNonCardedEventsResponse (87)
#endif

/* _ns1__RequestNonCardedEvents has binding name '_ns1__RequestNonCardedEvents' for type '' */
#ifndef SOAP_TYPE__ns1__RequestNonCardedEvents
#define SOAP_TYPE__ns1__RequestNonCardedEvents (86)
#endif

/* _ns1__GamePlayedAfterCardInResponse has binding name '_ns1__GamePlayedAfterCardInResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GamePlayedAfterCardInResponse
#define SOAP_TYPE__ns1__GamePlayedAfterCardInResponse (85)
#endif

/* _ns1__GamePlayedAfterCardIn has binding name '_ns1__GamePlayedAfterCardIn' for type '' */
#ifndef SOAP_TYPE__ns1__GamePlayedAfterCardIn
#define SOAP_TYPE__ns1__GamePlayedAfterCardIn (84)
#endif

/* _ns1__CardOutResponse has binding name '_ns1__CardOutResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CardOutResponse
#define SOAP_TYPE__ns1__CardOutResponse (83)
#endif

/* _ns1__CardOut has binding name '_ns1__CardOut' for type '' */
#ifndef SOAP_TYPE__ns1__CardOut
#define SOAP_TYPE__ns1__CardOut (82)
#endif

/* _ns1__CardInResponse has binding name '_ns1__CardInResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CardInResponse
#define SOAP_TYPE__ns1__CardInResponse (81)
#endif

/* _ns1__CardIn has binding name '_ns1__CardIn' for type '' */
#ifndef SOAP_TYPE__ns1__CardIn
#define SOAP_TYPE__ns1__CardIn (80)
#endif

/* _ns1__GetSpeedMediaVersionResponse has binding name '_ns1__GetSpeedMediaVersionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSpeedMediaVersionResponse
#define SOAP_TYPE__ns1__GetSpeedMediaVersionResponse (79)
#endif

/* _ns1__GetSpeedMediaVersion has binding name '_ns1__GetSpeedMediaVersion' for type '' */
#ifndef SOAP_TYPE__ns1__GetSpeedMediaVersion
#define SOAP_TYPE__ns1__GetSpeedMediaVersion (78)
#endif

/* _ns1__GetTriggerRejectedNotificationResponse has binding name '_ns1__GetTriggerRejectedNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse
#define SOAP_TYPE__ns1__GetTriggerRejectedNotificationResponse (77)
#endif

/* _ns1__GetTriggerRejectedNotification has binding name '_ns1__GetTriggerRejectedNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetTriggerRejectedNotification
#define SOAP_TYPE__ns1__GetTriggerRejectedNotification (76)
#endif

/* _ns1__GetExternalPaidNotificationResponse has binding name '_ns1__GetExternalPaidNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetExternalPaidNotificationResponse
#define SOAP_TYPE__ns1__GetExternalPaidNotificationResponse (75)
#endif

/* _ns1__GetExternalPaidNotification has binding name '_ns1__GetExternalPaidNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetExternalPaidNotification
#define SOAP_TYPE__ns1__GetExternalPaidNotification (74)
#endif

/* _ns1__GetTriggerlessAnnouncementNotificationResponse has binding name '_ns1__GetTriggerlessAnnouncementNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse
#define SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotificationResponse (73)
#endif

/* _ns1__GetTriggerlessAnnouncementNotification has binding name '_ns1__GetTriggerlessAnnouncementNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification
#define SOAP_TYPE__ns1__GetTriggerlessAnnouncementNotification (72)
#endif

/* _ns1__GetJackpotAnnouncementNotificationResponse has binding name '_ns1__GetJackpotAnnouncementNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse
#define SOAP_TYPE__ns1__GetJackpotAnnouncementNotificationResponse (71)
#endif

/* _ns1__GetJackpotAnnouncementNotification has binding name '_ns1__GetJackpotAnnouncementNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetJackpotAnnouncementNotification
#define SOAP_TYPE__ns1__GetJackpotAnnouncementNotification (70)
#endif

/* _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse has binding name '_ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse (69)
#endif

/* _ns1__GetRicochetAwardNotificationCustomWithMediaData has binding name '_ns1__GetRicochetAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomWithMediaData (68)
#endif

/* _ns1__GetRicochetAwardNotificationCustomResponse has binding name '_ns1__GetRicochetAwardNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustomResponse (67)
#endif

/* _ns1__GetRicochetAwardNotificationCustom has binding name '_ns1__GetRicochetAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom
#define SOAP_TYPE__ns1__GetRicochetAwardNotificationCustom (66)
#endif

/* _ns1__GetRicochetTriggeredEventNotificationCustomResponse has binding name '_ns1__GetRicochetTriggeredEventNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustomResponse (65)
#endif

/* _ns1__GetRicochetTriggeredEventNotificationCustom has binding name '_ns1__GetRicochetTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetRicochetTriggeredEventNotificationCustom (64)
#endif

/* _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse has binding name '_ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse (63)
#endif

/* _ns1__GetSplashdownAwardNotificationCustomWithMediaData has binding name '_ns1__GetSplashdownAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomWithMediaData (62)
#endif

/* _ns1__GetSplashdownAwardNotificationCustomResponse has binding name '_ns1__GetSplashdownAwardNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustomResponse (61)
#endif

/* _ns1__GetSplashdownAwardNotificationCustom has binding name '_ns1__GetSplashdownAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom
#define SOAP_TYPE__ns1__GetSplashdownAwardNotificationCustom (60)
#endif

/* _ns1__GetSplashdownTriggeredEventNotificationCustomResponse has binding name '_ns1__GetSplashdownTriggeredEventNotificationCustomResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse
#define SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustomResponse (59)
#endif

/* _ns1__GetSplashdownTriggeredEventNotificationCustom has binding name '_ns1__GetSplashdownTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom
#define SOAP_TYPE__ns1__GetSplashdownTriggeredEventNotificationCustom (58)
#endif

/* _ns1__GetSentinelConfigNotificationResponse has binding name '_ns1__GetSentinelConfigNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse
#define SOAP_TYPE__ns1__GetSentinelConfigNotificationResponse (57)
#endif

/* _ns1__GetSentinelConfigNotification has binding name '_ns1__GetSentinelConfigNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetSentinelConfigNotification
#define SOAP_TYPE__ns1__GetSentinelConfigNotification (56)
#endif

/* _ns1__GetCMPStatusNotificationResponse has binding name '_ns1__GetCMPStatusNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCMPStatusNotificationResponse
#define SOAP_TYPE__ns1__GetCMPStatusNotificationResponse (55)
#endif

/* _ns1__GetCMPStatusNotification has binding name '_ns1__GetCMPStatusNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetCMPStatusNotification
#define SOAP_TYPE__ns1__GetCMPStatusNotification (54)
#endif

/* _ns1__GetEventStartNotificationV25Response has binding name '_ns1__GetEventStartNotificationV25Response' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationV25Response
#define SOAP_TYPE__ns1__GetEventStartNotificationV25Response (53)
#endif

/* _ns1__GetEventStartNotificationV25 has binding name '_ns1__GetEventStartNotificationV25' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationV25
#define SOAP_TYPE__ns1__GetEventStartNotificationV25 (52)
#endif

/* _ns1__GetEventStartNotificationResponse has binding name '_ns1__GetEventStartNotificationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventStartNotificationResponse
#define SOAP_TYPE__ns1__GetEventStartNotificationResponse (51)
#endif

/* _ns1__GetEventStartNotification has binding name '_ns1__GetEventStartNotification' for type '' */
#ifndef SOAP_TYPE__ns1__GetEventStartNotification
#define SOAP_TYPE__ns1__GetEventStartNotification (50)
#endif

/* _ns1__CheckinResponse has binding name '_ns1__CheckinResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CheckinResponse
#define SOAP_TYPE__ns1__CheckinResponse (49)
#endif

/* _ns1__Checkin has binding name '_ns1__Checkin' for type '' */
#ifndef SOAP_TYPE__ns1__Checkin
#define SOAP_TYPE__ns1__Checkin (48)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (46)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (44)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (43)
#endif

/* xsd__unsignedByte_ has binding name 'xsd__unsignedByte_' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte_
#define SOAP_TYPE_xsd__unsignedByte_ (42)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (41)
#endif

/* xsd__short has binding name 'xsd__short' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short
#define SOAP_TYPE_xsd__short (39)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (37)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (36)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (34)
#endif

/* xsd__duration_ has binding name 'xsd__duration_' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (33)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (30)
#endif

/* xsd__decimal_ has binding name 'xsd__decimal_' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal_
#define SOAP_TYPE_xsd__decimal_ (29)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (26)
#endif

/* xsd__byte_ has binding name 'xsd__byte_' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte_
#define SOAP_TYPE_xsd__byte_ (25)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (23)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (22)
#endif

/* xsd__anyURI_ has binding name 'xsd__anyURI_' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (21)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (19)
#endif

/* xsd__IDREF_ has binding name 'xsd__IDREF_' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF_
#define SOAP_TYPE_xsd__IDREF_ (18)
#endif

/* xsd__ID_ has binding name 'xsd__ID_' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID_
#define SOAP_TYPE_xsd__ID_ (16)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (564)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (563)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (560)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (558)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (556)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (550)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (513)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (512)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (511)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (510)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (509)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (508)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (507)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (506)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (505)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (504)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (503)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (502)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (501)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (500)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (499)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (498)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (497)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (496)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (495)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (494)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (493)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (492)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (491)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (459)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (458)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (457)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (456)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (455)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (454)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (453)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (452)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (451)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (450)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (449)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (448)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (447)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (446)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (445)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (444)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (443)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (442)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (441)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (440)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (434)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (433)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (432)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (418)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (417)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (416)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (415)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (414)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (413)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (412)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (411)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (410)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (409)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (408)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (407)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (396)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (395)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (394)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (393)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (390)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (388)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (387)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (386)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (384)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (383)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (382)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (381)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (380)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (379)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (378)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (376)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (374)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (373)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (370)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (366)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (365)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (364)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (363)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (362)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (359)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (358)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (356)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (355)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (566)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (565)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (559)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (557)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (555)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (554)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (553)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (552)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (551)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (549)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (548)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (547)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (545)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (544)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (543)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (542)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (541)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (539)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (538)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (536)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (535)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (534)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (533)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (532)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (530)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (529)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (528)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (527)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (526)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (525)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (524)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (523)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (522)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (520)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (519)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (518)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (517)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (516)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (515)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (490)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (489)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (488)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (487)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (486)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (485)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (484)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (483)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (481)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (480)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (479)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (478)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (476)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (475)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (474)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (473)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (472)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (470)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (469)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (468)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (467)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (466)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (465)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (464)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (462)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (461)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (439)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (438)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (435)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (430)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (429)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (428)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (427)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (425)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (424)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (423)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (422)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (421)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (420)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (419)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (406)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (405)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (404)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (403)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (402)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (401)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (400)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (399)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (398)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (397)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (392)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (391)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (389)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (385)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (377)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (375)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (372)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (371)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (369)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (368)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (367)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (361)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (360)
#endif

/* _ns1__GetCacheMethodList * has binding name 'PointerTo_ns1__GetCacheMethodList' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCacheMethodList
#define SOAP_TYPE_PointerTo_ns1__GetCacheMethodList (350)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData * has binding name 'PointerTo_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData
#define SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData (346)
#endif

/* _ns1__GetCasinoChallengeAwardNotificationCustom * has binding name 'PointerTo_ns1__GetCasinoChallengeAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeAwardNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeAwardNotificationCustom (342)
#endif

/* _ns1__GetCasinoChallangeEventEndNotificationCustom * has binding name 'PointerTo_ns1__GetCasinoChallangeEventEndNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCasinoChallangeEventEndNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetCasinoChallangeEventEndNotificationCustom (338)
#endif

/* _ns1__GetCasinoChallangeIncrementNotification * has binding name 'PointerTo_ns1__GetCasinoChallangeIncrementNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCasinoChallangeIncrementNotification
#define SOAP_TYPE_PointerTo_ns1__GetCasinoChallangeIncrementNotification (334)
#endif

/* _ns1__GetCasinoChallengeTriggeredEventNotificationCustom * has binding name 'PointerTo_ns1__GetCasinoChallengeTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeTriggeredEventNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetCasinoChallengeTriggeredEventNotificationCustom (330)
#endif

/* _ns1__GetEventTriggerNotification * has binding name 'PointerTo_ns1__GetEventTriggerNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEventTriggerNotification
#define SOAP_TYPE_PointerTo_ns1__GetEventTriggerNotification (326)
#endif

/* _ns1__SendBlobToThirdParty * has binding name 'PointerTo_ns1__SendBlobToThirdParty' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SendBlobToThirdParty
#define SOAP_TYPE_PointerTo_ns1__SendBlobToThirdParty (322)
#endif

/* _ns1__GetThirdPartyBlob * has binding name 'PointerTo_ns1__GetThirdPartyBlob' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetThirdPartyBlob
#define SOAP_TYPE_PointerTo_ns1__GetThirdPartyBlob (318)
#endif

/* _ns1__ReportSentinelInformation25 * has binding name 'PointerTo_ns1__ReportSentinelInformation25' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportSentinelInformation25
#define SOAP_TYPE_PointerTo_ns1__ReportSentinelInformation25 (314)
#endif

/* _ns1__ReportSentinelInformationEx * has binding name 'PointerTo_ns1__ReportSentinelInformationEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportSentinelInformationEx
#define SOAP_TYPE_PointerTo_ns1__ReportSentinelInformationEx (310)
#endif

/* _ns1__ReportSentinelInformationWithOrientation * has binding name 'PointerTo_ns1__ReportSentinelInformationWithOrientation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportSentinelInformationWithOrientation
#define SOAP_TYPE_PointerTo_ns1__ReportSentinelInformationWithOrientation (306)
#endif

/* _ns1__ReportSentinelInformation * has binding name 'PointerTo_ns1__ReportSentinelInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportSentinelInformation
#define SOAP_TYPE_PointerTo_ns1__ReportSentinelInformation (302)
#endif

/* _ns1__ReportStatus * has binding name 'PointerTo_ns1__ReportStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportStatus
#define SOAP_TYPE_PointerTo_ns1__ReportStatus (298)
#endif

/* _ns1__AcknowledgeExternalPaid * has binding name 'PointerTo_ns1__AcknowledgeExternalPaid' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__AcknowledgeExternalPaid
#define SOAP_TYPE_PointerTo_ns1__AcknowledgeExternalPaid (294)
#endif

/* _ns1__ReportGameStart * has binding name 'PointerTo_ns1__ReportGameStart' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportGameStart
#define SOAP_TYPE_PointerTo_ns1__ReportGameStart (290)
#endif

/* _ns1__ReportEventMeterDeltas * has binding name 'PointerTo_ns1__ReportEventMeterDeltas' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportEventMeterDeltas
#define SOAP_TYPE_PointerTo_ns1__ReportEventMeterDeltas (286)
#endif

/* _ns1__InTriggeredEventTrigger * has binding name 'PointerTo_ns1__InTriggeredEventTrigger' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InTriggeredEventTrigger
#define SOAP_TYPE_PointerTo_ns1__InTriggeredEventTrigger (282)
#endif

/* _ns1__InEventTrigger * has binding name 'PointerTo_ns1__InEventTrigger' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__InEventTrigger
#define SOAP_TYPE_PointerTo_ns1__InEventTrigger (278)
#endif

/* _ns1__GetEventXMLFile * has binding name 'PointerTo_ns1__GetEventXMLFile' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEventXMLFile
#define SOAP_TYPE_PointerTo_ns1__GetEventXMLFile (274)
#endif

/* _ns1__GetConfigEx * has binding name 'PointerTo_ns1__GetConfigEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetConfigEx
#define SOAP_TYPE_PointerTo_ns1__GetConfigEx (270)
#endif

/* _ns1__GetConfig * has binding name 'PointerTo_ns1__GetConfig' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetConfig
#define SOAP_TYPE_PointerTo_ns1__GetConfig (266)
#endif

/* _ns1__GetFileInformation * has binding name 'PointerTo_ns1__GetFileInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFileInformation
#define SOAP_TYPE_PointerTo_ns1__GetFileInformation (262)
#endif

/* _ns1__GetFlashUdpCompleteAnnouncement * has binding name 'PointerTo_ns1__GetFlashUdpCompleteAnnouncement' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFlashUdpCompleteAnnouncement
#define SOAP_TYPE_PointerTo_ns1__GetFlashUdpCompleteAnnouncement (258)
#endif

/* _ns1__GetFlashStartAnnouncement * has binding name 'PointerTo_ns1__GetFlashStartAnnouncement' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFlashStartAnnouncement
#define SOAP_TYPE_PointerTo_ns1__GetFlashStartAnnouncement (254)
#endif

/* _ns1__RequestNonCardedEvents * has binding name 'PointerTo_ns1__RequestNonCardedEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RequestNonCardedEvents
#define SOAP_TYPE_PointerTo_ns1__RequestNonCardedEvents (250)
#endif

/* _ns1__GamePlayedAfterCardIn * has binding name 'PointerTo_ns1__GamePlayedAfterCardIn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GamePlayedAfterCardIn
#define SOAP_TYPE_PointerTo_ns1__GamePlayedAfterCardIn (246)
#endif

/* _ns1__CardOut * has binding name 'PointerTo_ns1__CardOut' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CardOut
#define SOAP_TYPE_PointerTo_ns1__CardOut (242)
#endif

/* _ns1__CardIn * has binding name 'PointerTo_ns1__CardIn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CardIn
#define SOAP_TYPE_PointerTo_ns1__CardIn (238)
#endif

/* _ns1__GetSpeedMediaVersion * has binding name 'PointerTo_ns1__GetSpeedMediaVersion' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSpeedMediaVersion
#define SOAP_TYPE_PointerTo_ns1__GetSpeedMediaVersion (234)
#endif

/* _ns1__GetTriggerRejectedNotification * has binding name 'PointerTo_ns1__GetTriggerRejectedNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTriggerRejectedNotification
#define SOAP_TYPE_PointerTo_ns1__GetTriggerRejectedNotification (230)
#endif

/* _ns1__GetExternalPaidNotification * has binding name 'PointerTo_ns1__GetExternalPaidNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetExternalPaidNotification
#define SOAP_TYPE_PointerTo_ns1__GetExternalPaidNotification (226)
#endif

/* _ns1__GetTriggerlessAnnouncementNotification * has binding name 'PointerTo_ns1__GetTriggerlessAnnouncementNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTriggerlessAnnouncementNotification
#define SOAP_TYPE_PointerTo_ns1__GetTriggerlessAnnouncementNotification (222)
#endif

/* _ns1__GetJackpotAnnouncementNotification * has binding name 'PointerTo_ns1__GetJackpotAnnouncementNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetJackpotAnnouncementNotification
#define SOAP_TYPE_PointerTo_ns1__GetJackpotAnnouncementNotification (218)
#endif

/* _ns1__GetRicochetAwardNotificationCustomWithMediaData * has binding name 'PointerTo_ns1__GetRicochetAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRicochetAwardNotificationCustomWithMediaData
#define SOAP_TYPE_PointerTo_ns1__GetRicochetAwardNotificationCustomWithMediaData (214)
#endif

/* _ns1__GetRicochetAwardNotificationCustom * has binding name 'PointerTo_ns1__GetRicochetAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRicochetAwardNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetRicochetAwardNotificationCustom (210)
#endif

/* _ns1__GetRicochetTriggeredEventNotificationCustom * has binding name 'PointerTo_ns1__GetRicochetTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetRicochetTriggeredEventNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetRicochetTriggeredEventNotificationCustom (206)
#endif

/* _ns1__GetSplashdownAwardNotificationCustomWithMediaData * has binding name 'PointerTo_ns1__GetSplashdownAwardNotificationCustomWithMediaData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSplashdownAwardNotificationCustomWithMediaData
#define SOAP_TYPE_PointerTo_ns1__GetSplashdownAwardNotificationCustomWithMediaData (202)
#endif

/* _ns1__GetSplashdownAwardNotificationCustom * has binding name 'PointerTo_ns1__GetSplashdownAwardNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSplashdownAwardNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetSplashdownAwardNotificationCustom (198)
#endif

/* _ns1__GetSplashdownTriggeredEventNotificationCustom * has binding name 'PointerTo_ns1__GetSplashdownTriggeredEventNotificationCustom' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSplashdownTriggeredEventNotificationCustom
#define SOAP_TYPE_PointerTo_ns1__GetSplashdownTriggeredEventNotificationCustom (194)
#endif

/* _ns1__GetSentinelConfigNotification * has binding name 'PointerTo_ns1__GetSentinelConfigNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetSentinelConfigNotification
#define SOAP_TYPE_PointerTo_ns1__GetSentinelConfigNotification (190)
#endif

/* _ns1__GetCMPStatusNotification * has binding name 'PointerTo_ns1__GetCMPStatusNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCMPStatusNotification
#define SOAP_TYPE_PointerTo_ns1__GetCMPStatusNotification (186)
#endif

/* _ns1__GetEventStartNotificationV25 * has binding name 'PointerTo_ns1__GetEventStartNotificationV25' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEventStartNotificationV25
#define SOAP_TYPE_PointerTo_ns1__GetEventStartNotificationV25 (182)
#endif

/* _ns1__GetEventStartNotification * has binding name 'PointerTo_ns1__GetEventStartNotification' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetEventStartNotification
#define SOAP_TYPE_PointerTo_ns1__GetEventStartNotification (178)
#endif

/* _ns1__Checkin * has binding name 'PointerTo_ns1__Checkin' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Checkin
#define SOAP_TYPE_PointerTo_ns1__Checkin (174)
#endif

/* enum ns3__EventData_x002eCustomMessageJustificationType * has binding name 'PointerTons3__EventData_x002eCustomMessageJustificationType' for type 'ns3:EventData.CustomMessageJustificationType' */
#ifndef SOAP_TYPE_PointerTons3__EventData_x002eCustomMessageJustificationType
#define SOAP_TYPE_PointerTons3__EventData_x002eCustomMessageJustificationType (173)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (172)
#endif

/* ns3__CustomMessageLine ** has binding name 'PointerToPointerTons3__CustomMessageLine' for type 'ns3:CustomMessageLine' */
#ifndef SOAP_TYPE_PointerToPointerTons3__CustomMessageLine
#define SOAP_TYPE_PointerToPointerTons3__CustomMessageLine (171)
#endif

/* ns3__CustomMessageLine * has binding name 'PointerTons3__CustomMessageLine' for type 'ns3:CustomMessageLine' */
#ifndef SOAP_TYPE_PointerTons3__CustomMessageLine
#define SOAP_TYPE_PointerTons3__CustomMessageLine (170)
#endif

/* ns3__ArrayOfCustomMessageLine * has binding name 'PointerTons3__ArrayOfCustomMessageLine' for type 'ns3:ArrayOfCustomMessageLine' */
#ifndef SOAP_TYPE_PointerTons3__ArrayOfCustomMessageLine
#define SOAP_TYPE_PointerTons3__ArrayOfCustomMessageLine (169)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (168)
#endif

/* _ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring * has binding name 'PointerTo_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring
#define SOAP_TYPE_PointerTo_ns2__ArrayOfKeyValueOfstringstring_KeyValueOfstringstring (167)
#endif

/* ns2__ArrayOfstring * has binding name 'PointerTons2__ArrayOfstring' for type 'ns2:ArrayOfstring' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfstring
#define SOAP_TYPE_PointerTons2__ArrayOfstring (165)
#endif

/* unsigned char * has binding name 'PointerToxsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerToxsd__unsignedByte
#define SOAP_TYPE_PointerToxsd__unsignedByte (164)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_PointerToLONG64
#define SOAP_TYPE_PointerToLONG64 (163)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (162)
#endif

/* ns3__CustomMessageScreen * has binding name 'PointerTons3__CustomMessageScreen' for type 'ns3:CustomMessageScreen' */
#ifndef SOAP_TYPE_PointerTons3__CustomMessageScreen
#define SOAP_TYPE_PointerTons3__CustomMessageScreen (161)
#endif

/* ns2__ArrayOfKeyValueOfstringstring * has binding name 'PointerTons2__ArrayOfKeyValueOfstringstring' for type 'ns2:ArrayOfKeyValueOfstringstring' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfKeyValueOfstringstring
#define SOAP_TYPE_PointerTons2__ArrayOfKeyValueOfstringstring (160)
#endif

/* ns2__ArrayOflong * has binding name 'PointerTons2__ArrayOflong' for type 'ns2:ArrayOflong' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOflong
#define SOAP_TYPE_PointerTons2__ArrayOflong (159)
#endif

/* ns2__ArrayOfint * has binding name 'PointerTons2__ArrayOfint' for type 'ns2:ArrayOfint' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfint
#define SOAP_TYPE_PointerTons2__ArrayOfint (158)
#endif

/* ns2__ArrayOfbase64Binary * has binding name 'PointerTons2__ArrayOfbase64Binary' for type 'ns2:ArrayOfbase64Binary' */
#ifndef SOAP_TYPE_PointerTons2__ArrayOfbase64Binary
#define SOAP_TYPE_PointerTons2__ArrayOfbase64Binary (157)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (156)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (155)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (154)
#endif

/* ns4__guid has binding name 'ns4__guid' for type 'ns4:guid' */
#ifndef SOAP_TYPE_ns4__guid
#define SOAP_TYPE_ns4__guid (152)
#endif

/* ns4__duration has binding name 'ns4__duration' for type 'ns4:duration' */
#ifndef SOAP_TYPE_ns4__duration
#define SOAP_TYPE_ns4__duration (150)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (32)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (28)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (20)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (17)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (15)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (12)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Checkin(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Checkin *ns1__Checkin, _ns1__CheckinResponse &ns1__CheckinResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetEventStartNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEventStartNotification *ns1__GetEventStartNotification, _ns1__GetEventStartNotificationResponse &ns1__GetEventStartNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetEventStartNotificationV25(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEventStartNotificationV25 *ns1__GetEventStartNotificationV25, _ns1__GetEventStartNotificationV25Response &ns1__GetEventStartNotificationV25Response);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCMPStatusNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCMPStatusNotification *ns1__GetCMPStatusNotification, _ns1__GetCMPStatusNotificationResponse &ns1__GetCMPStatusNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSentinelConfigNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSentinelConfigNotification *ns1__GetSentinelConfigNotification, _ns1__GetSentinelConfigNotificationResponse &ns1__GetSentinelConfigNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSplashdownTriggeredEventNotificationCustom *ns1__GetSplashdownTriggeredEventNotificationCustom, _ns1__GetSplashdownTriggeredEventNotificationCustomResponse &ns1__GetSplashdownTriggeredEventNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSplashdownAwardNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSplashdownAwardNotificationCustom *ns1__GetSplashdownAwardNotificationCustom, _ns1__GetSplashdownAwardNotificationCustomResponse &ns1__GetSplashdownAwardNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSplashdownAwardNotificationCustomWithMediaData *ns1__GetSplashdownAwardNotificationCustomWithMediaData, _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse &ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetRicochetTriggeredEventNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetRicochetTriggeredEventNotificationCustom *ns1__GetRicochetTriggeredEventNotificationCustom, _ns1__GetRicochetTriggeredEventNotificationCustomResponse &ns1__GetRicochetTriggeredEventNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetRicochetAwardNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetRicochetAwardNotificationCustom *ns1__GetRicochetAwardNotificationCustom, _ns1__GetRicochetAwardNotificationCustomResponse &ns1__GetRicochetAwardNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetRicochetAwardNotificationCustomWithMediaData *ns1__GetRicochetAwardNotificationCustomWithMediaData, _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse &ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetJackpotAnnouncementNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetJackpotAnnouncementNotification *ns1__GetJackpotAnnouncementNotification, _ns1__GetJackpotAnnouncementNotificationResponse &ns1__GetJackpotAnnouncementNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTriggerlessAnnouncementNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTriggerlessAnnouncementNotification *ns1__GetTriggerlessAnnouncementNotification, _ns1__GetTriggerlessAnnouncementNotificationResponse &ns1__GetTriggerlessAnnouncementNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetExternalPaidNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetExternalPaidNotification *ns1__GetExternalPaidNotification, _ns1__GetExternalPaidNotificationResponse &ns1__GetExternalPaidNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTriggerRejectedNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTriggerRejectedNotification *ns1__GetTriggerRejectedNotification, _ns1__GetTriggerRejectedNotificationResponse &ns1__GetTriggerRejectedNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetSpeedMediaVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetSpeedMediaVersion *ns1__GetSpeedMediaVersion, _ns1__GetSpeedMediaVersionResponse &ns1__GetSpeedMediaVersionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CardIn(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CardIn *ns1__CardIn, _ns1__CardInResponse &ns1__CardInResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CardOut(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CardOut *ns1__CardOut, _ns1__CardOutResponse &ns1__CardOutResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GamePlayedAfterCardIn(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GamePlayedAfterCardIn *ns1__GamePlayedAfterCardIn, _ns1__GamePlayedAfterCardInResponse &ns1__GamePlayedAfterCardInResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__RequestNonCardedEvents(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__RequestNonCardedEvents *ns1__RequestNonCardedEvents, _ns1__RequestNonCardedEventsResponse &ns1__RequestNonCardedEventsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFlashStartAnnouncement(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFlashStartAnnouncement *ns1__GetFlashStartAnnouncement, _ns1__GetFlashStartAnnouncementResponse &ns1__GetFlashStartAnnouncementResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFlashUdpCompleteAnnouncement(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFlashUdpCompleteAnnouncement *ns1__GetFlashUdpCompleteAnnouncement, _ns1__GetFlashUdpCompleteAnnouncementResponse &ns1__GetFlashUdpCompleteAnnouncementResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFileInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFileInformation *ns1__GetFileInformation, _ns1__GetFileInformationResponse &ns1__GetFileInformationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetConfig *ns1__GetConfig, _ns1__GetConfigResponse &ns1__GetConfigResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetConfigEx(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetConfigEx *ns1__GetConfigEx, _ns1__GetConfigExResponse &ns1__GetConfigExResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetEventXMLFile(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEventXMLFile *ns1__GetEventXMLFile, _ns1__GetEventXMLFileResponse &ns1__GetEventXMLFileResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InEventTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InEventTrigger *ns1__InEventTrigger, _ns1__InEventTriggerResponse &ns1__InEventTriggerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__InTriggeredEventTrigger(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__InTriggeredEventTrigger *ns1__InTriggeredEventTrigger, _ns1__InTriggeredEventTriggerResponse &ns1__InTriggeredEventTriggerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportEventMeterDeltas(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportEventMeterDeltas *ns1__ReportEventMeterDeltas, _ns1__ReportEventMeterDeltasResponse &ns1__ReportEventMeterDeltasResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportGameStart(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportGameStart *ns1__ReportGameStart, _ns1__ReportGameStartResponse &ns1__ReportGameStartResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__AcknowledgeExternalPaid(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__AcknowledgeExternalPaid *ns1__AcknowledgeExternalPaid, _ns1__AcknowledgeExternalPaidResponse &ns1__AcknowledgeExternalPaidResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportStatus *ns1__ReportStatus, _ns1__ReportStatusResponse &ns1__ReportStatusResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportSentinelInformation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportSentinelInformation *ns1__ReportSentinelInformation, _ns1__ReportSentinelInformationResponse &ns1__ReportSentinelInformationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportSentinelInformationWithOrientation(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportSentinelInformationWithOrientation *ns1__ReportSentinelInformationWithOrientation, _ns1__ReportSentinelInformationWithOrientationResponse &ns1__ReportSentinelInformationWithOrientationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportSentinelInformationEx(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportSentinelInformationEx *ns1__ReportSentinelInformationEx, _ns1__ReportSentinelInformationExResponse &ns1__ReportSentinelInformationExResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ReportSentinelInformation25(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ReportSentinelInformation25 *ns1__ReportSentinelInformation25, _ns1__ReportSentinelInformation25Response &ns1__ReportSentinelInformation25Response);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetThirdPartyBlob(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetThirdPartyBlob *ns1__GetThirdPartyBlob, _ns1__GetThirdPartyBlobResponse &ns1__GetThirdPartyBlobResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SendBlobToThirdParty(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SendBlobToThirdParty *ns1__SendBlobToThirdParty, _ns1__SendBlobToThirdPartyResponse &ns1__SendBlobToThirdPartyResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetEventTriggerNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetEventTriggerNotification *ns1__GetEventTriggerNotification, _ns1__GetEventTriggerNotificationResponse &ns1__GetEventTriggerNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCasinoChallengeTriggeredEventNotificationCustom *ns1__GetCasinoChallengeTriggeredEventNotificationCustom, _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse &ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCasinoChallangeIncrementNotification(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCasinoChallangeIncrementNotification *ns1__GetCasinoChallangeIncrementNotification, _ns1__GetCasinoChallangeIncrementNotificationResponse &ns1__GetCasinoChallangeIncrementNotificationResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCasinoChallangeEventEndNotificationCustom *ns1__GetCasinoChallangeEventEndNotificationCustom, _ns1__GetCasinoChallangeEventEndNotificationCustomResponse &ns1__GetCasinoChallangeEventEndNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCasinoChallengeAwardNotificationCustom(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCasinoChallengeAwardNotificationCustom *ns1__GetCasinoChallengeAwardNotificationCustom, _ns1__GetCasinoChallengeAwardNotificationCustomResponse &ns1__GetCasinoChallengeAwardNotificationCustomResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData *ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData, _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse &ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCacheMethodList(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCacheMethodList *ns1__GetCacheMethodList, _ns1__GetCacheMethodListResponse &ns1__GetCacheMethodListResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__ns1__Checkin' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Checkin(struct soap*, _ns1__Checkin *ns1__Checkin, _ns1__CheckinResponse &ns1__CheckinResponse);
    /** Web service operation '__ns1__GetEventStartNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetEventStartNotification(struct soap*, _ns1__GetEventStartNotification *ns1__GetEventStartNotification, _ns1__GetEventStartNotificationResponse &ns1__GetEventStartNotificationResponse);
    /** Web service operation '__ns1__GetEventStartNotificationV25' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetEventStartNotificationV25(struct soap*, _ns1__GetEventStartNotificationV25 *ns1__GetEventStartNotificationV25, _ns1__GetEventStartNotificationV25Response &ns1__GetEventStartNotificationV25Response);
    /** Web service operation '__ns1__GetCMPStatusNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCMPStatusNotification(struct soap*, _ns1__GetCMPStatusNotification *ns1__GetCMPStatusNotification, _ns1__GetCMPStatusNotificationResponse &ns1__GetCMPStatusNotificationResponse);
    /** Web service operation '__ns1__GetSentinelConfigNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSentinelConfigNotification(struct soap*, _ns1__GetSentinelConfigNotification *ns1__GetSentinelConfigNotification, _ns1__GetSentinelConfigNotificationResponse &ns1__GetSentinelConfigNotificationResponse);
    /** Web service operation '__ns1__GetSplashdownTriggeredEventNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*, _ns1__GetSplashdownTriggeredEventNotificationCustom *ns1__GetSplashdownTriggeredEventNotificationCustom, _ns1__GetSplashdownTriggeredEventNotificationCustomResponse &ns1__GetSplashdownTriggeredEventNotificationCustomResponse);
    /** Web service operation '__ns1__GetSplashdownAwardNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSplashdownAwardNotificationCustom(struct soap*, _ns1__GetSplashdownAwardNotificationCustom *ns1__GetSplashdownAwardNotificationCustom, _ns1__GetSplashdownAwardNotificationCustomResponse &ns1__GetSplashdownAwardNotificationCustomResponse);
    /** Web service operation '__ns1__GetSplashdownAwardNotificationCustomWithMediaData' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*, _ns1__GetSplashdownAwardNotificationCustomWithMediaData *ns1__GetSplashdownAwardNotificationCustomWithMediaData, _ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse &ns1__GetSplashdownAwardNotificationCustomWithMediaDataResponse);
    /** Web service operation '__ns1__GetRicochetTriggeredEventNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*, _ns1__GetRicochetTriggeredEventNotificationCustom *ns1__GetRicochetTriggeredEventNotificationCustom, _ns1__GetRicochetTriggeredEventNotificationCustomResponse &ns1__GetRicochetTriggeredEventNotificationCustomResponse);
    /** Web service operation '__ns1__GetRicochetAwardNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetRicochetAwardNotificationCustom(struct soap*, _ns1__GetRicochetAwardNotificationCustom *ns1__GetRicochetAwardNotificationCustom, _ns1__GetRicochetAwardNotificationCustomResponse &ns1__GetRicochetAwardNotificationCustomResponse);
    /** Web service operation '__ns1__GetRicochetAwardNotificationCustomWithMediaData' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*, _ns1__GetRicochetAwardNotificationCustomWithMediaData *ns1__GetRicochetAwardNotificationCustomWithMediaData, _ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse &ns1__GetRicochetAwardNotificationCustomWithMediaDataResponse);
    /** Web service operation '__ns1__GetJackpotAnnouncementNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetJackpotAnnouncementNotification(struct soap*, _ns1__GetJackpotAnnouncementNotification *ns1__GetJackpotAnnouncementNotification, _ns1__GetJackpotAnnouncementNotificationResponse &ns1__GetJackpotAnnouncementNotificationResponse);
    /** Web service operation '__ns1__GetTriggerlessAnnouncementNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetTriggerlessAnnouncementNotification(struct soap*, _ns1__GetTriggerlessAnnouncementNotification *ns1__GetTriggerlessAnnouncementNotification, _ns1__GetTriggerlessAnnouncementNotificationResponse &ns1__GetTriggerlessAnnouncementNotificationResponse);
    /** Web service operation '__ns1__GetExternalPaidNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetExternalPaidNotification(struct soap*, _ns1__GetExternalPaidNotification *ns1__GetExternalPaidNotification, _ns1__GetExternalPaidNotificationResponse &ns1__GetExternalPaidNotificationResponse);
    /** Web service operation '__ns1__GetTriggerRejectedNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetTriggerRejectedNotification(struct soap*, _ns1__GetTriggerRejectedNotification *ns1__GetTriggerRejectedNotification, _ns1__GetTriggerRejectedNotificationResponse &ns1__GetTriggerRejectedNotificationResponse);
    /** Web service operation '__ns1__GetSpeedMediaVersion' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetSpeedMediaVersion(struct soap*, _ns1__GetSpeedMediaVersion *ns1__GetSpeedMediaVersion, _ns1__GetSpeedMediaVersionResponse &ns1__GetSpeedMediaVersionResponse);
    /** Web service operation '__ns1__CardIn' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CardIn(struct soap*, _ns1__CardIn *ns1__CardIn, _ns1__CardInResponse &ns1__CardInResponse);
    /** Web service operation '__ns1__CardOut' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CardOut(struct soap*, _ns1__CardOut *ns1__CardOut, _ns1__CardOutResponse &ns1__CardOutResponse);
    /** Web service operation '__ns1__GamePlayedAfterCardIn' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GamePlayedAfterCardIn(struct soap*, _ns1__GamePlayedAfterCardIn *ns1__GamePlayedAfterCardIn, _ns1__GamePlayedAfterCardInResponse &ns1__GamePlayedAfterCardInResponse);
    /** Web service operation '__ns1__RequestNonCardedEvents' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__RequestNonCardedEvents(struct soap*, _ns1__RequestNonCardedEvents *ns1__RequestNonCardedEvents, _ns1__RequestNonCardedEventsResponse &ns1__RequestNonCardedEventsResponse);
    /** Web service operation '__ns1__GetFlashStartAnnouncement' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetFlashStartAnnouncement(struct soap*, _ns1__GetFlashStartAnnouncement *ns1__GetFlashStartAnnouncement, _ns1__GetFlashStartAnnouncementResponse &ns1__GetFlashStartAnnouncementResponse);
    /** Web service operation '__ns1__GetFlashUdpCompleteAnnouncement' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetFlashUdpCompleteAnnouncement(struct soap*, _ns1__GetFlashUdpCompleteAnnouncement *ns1__GetFlashUdpCompleteAnnouncement, _ns1__GetFlashUdpCompleteAnnouncementResponse &ns1__GetFlashUdpCompleteAnnouncementResponse);
    /** Web service operation '__ns1__GetFileInformation' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetFileInformation(struct soap*, _ns1__GetFileInformation *ns1__GetFileInformation, _ns1__GetFileInformationResponse &ns1__GetFileInformationResponse);
    /** Web service operation '__ns1__GetConfig' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetConfig(struct soap*, _ns1__GetConfig *ns1__GetConfig, _ns1__GetConfigResponse &ns1__GetConfigResponse);
    /** Web service operation '__ns1__GetConfigEx' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetConfigEx(struct soap*, _ns1__GetConfigEx *ns1__GetConfigEx, _ns1__GetConfigExResponse &ns1__GetConfigExResponse);
    /** Web service operation '__ns1__GetEventXMLFile' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetEventXMLFile(struct soap*, _ns1__GetEventXMLFile *ns1__GetEventXMLFile, _ns1__GetEventXMLFileResponse &ns1__GetEventXMLFileResponse);
    /** Web service operation '__ns1__InEventTrigger' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__InEventTrigger(struct soap*, _ns1__InEventTrigger *ns1__InEventTrigger, _ns1__InEventTriggerResponse &ns1__InEventTriggerResponse);
    /** Web service operation '__ns1__InTriggeredEventTrigger' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__InTriggeredEventTrigger(struct soap*, _ns1__InTriggeredEventTrigger *ns1__InTriggeredEventTrigger, _ns1__InTriggeredEventTriggerResponse &ns1__InTriggeredEventTriggerResponse);
    /** Web service operation '__ns1__ReportEventMeterDeltas' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportEventMeterDeltas(struct soap*, _ns1__ReportEventMeterDeltas *ns1__ReportEventMeterDeltas, _ns1__ReportEventMeterDeltasResponse &ns1__ReportEventMeterDeltasResponse);
    /** Web service operation '__ns1__ReportGameStart' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportGameStart(struct soap*, _ns1__ReportGameStart *ns1__ReportGameStart, _ns1__ReportGameStartResponse &ns1__ReportGameStartResponse);
    /** Web service operation '__ns1__AcknowledgeExternalPaid' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__AcknowledgeExternalPaid(struct soap*, _ns1__AcknowledgeExternalPaid *ns1__AcknowledgeExternalPaid, _ns1__AcknowledgeExternalPaidResponse &ns1__AcknowledgeExternalPaidResponse);
    /** Web service operation '__ns1__ReportStatus' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportStatus(struct soap*, _ns1__ReportStatus *ns1__ReportStatus, _ns1__ReportStatusResponse &ns1__ReportStatusResponse);
    /** Web service operation '__ns1__ReportSentinelInformation' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportSentinelInformation(struct soap*, _ns1__ReportSentinelInformation *ns1__ReportSentinelInformation, _ns1__ReportSentinelInformationResponse &ns1__ReportSentinelInformationResponse);
    /** Web service operation '__ns1__ReportSentinelInformationWithOrientation' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportSentinelInformationWithOrientation(struct soap*, _ns1__ReportSentinelInformationWithOrientation *ns1__ReportSentinelInformationWithOrientation, _ns1__ReportSentinelInformationWithOrientationResponse &ns1__ReportSentinelInformationWithOrientationResponse);
    /** Web service operation '__ns1__ReportSentinelInformationEx' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportSentinelInformationEx(struct soap*, _ns1__ReportSentinelInformationEx *ns1__ReportSentinelInformationEx, _ns1__ReportSentinelInformationExResponse &ns1__ReportSentinelInformationExResponse);
    /** Web service operation '__ns1__ReportSentinelInformation25' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ReportSentinelInformation25(struct soap*, _ns1__ReportSentinelInformation25 *ns1__ReportSentinelInformation25, _ns1__ReportSentinelInformation25Response &ns1__ReportSentinelInformation25Response);
    /** Web service operation '__ns1__GetThirdPartyBlob' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetThirdPartyBlob(struct soap*, _ns1__GetThirdPartyBlob *ns1__GetThirdPartyBlob, _ns1__GetThirdPartyBlobResponse &ns1__GetThirdPartyBlobResponse);
    /** Web service operation '__ns1__SendBlobToThirdParty' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SendBlobToThirdParty(struct soap*, _ns1__SendBlobToThirdParty *ns1__SendBlobToThirdParty, _ns1__SendBlobToThirdPartyResponse &ns1__SendBlobToThirdPartyResponse);
    /** Web service operation '__ns1__GetEventTriggerNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetEventTriggerNotification(struct soap*, _ns1__GetEventTriggerNotification *ns1__GetEventTriggerNotification, _ns1__GetEventTriggerNotificationResponse &ns1__GetEventTriggerNotificationResponse);
    /** Web service operation '__ns1__GetCasinoChallengeTriggeredEventNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*, _ns1__GetCasinoChallengeTriggeredEventNotificationCustom *ns1__GetCasinoChallengeTriggeredEventNotificationCustom, _ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse &ns1__GetCasinoChallengeTriggeredEventNotificationCustomResponse);
    /** Web service operation '__ns1__GetCasinoChallangeIncrementNotification' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCasinoChallangeIncrementNotification(struct soap*, _ns1__GetCasinoChallangeIncrementNotification *ns1__GetCasinoChallangeIncrementNotification, _ns1__GetCasinoChallangeIncrementNotificationResponse &ns1__GetCasinoChallangeIncrementNotificationResponse);
    /** Web service operation '__ns1__GetCasinoChallangeEventEndNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*, _ns1__GetCasinoChallangeEventEndNotificationCustom *ns1__GetCasinoChallangeEventEndNotificationCustom, _ns1__GetCasinoChallangeEventEndNotificationCustomResponse &ns1__GetCasinoChallangeEventEndNotificationCustomResponse);
    /** Web service operation '__ns1__GetCasinoChallengeAwardNotificationCustom' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*, _ns1__GetCasinoChallengeAwardNotificationCustom *ns1__GetCasinoChallengeAwardNotificationCustom, _ns1__GetCasinoChallengeAwardNotificationCustomResponse &ns1__GetCasinoChallengeAwardNotificationCustomResponse);
    /** Web service operation '__ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*, _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData *ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData, _ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse &ns1__GetCasinoChallengeAwardNotificationCustomWithMediaDataResponse);
    /** Web service operation '__ns1__GetCacheMethodList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCacheMethodList(struct soap*, _ns1__GetCacheMethodList *ns1__GetCacheMethodList, _ns1__GetCacheMethodListResponse &ns1__GetCacheMethodListResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Checkin(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetEventStartNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetEventStartNotificationV25(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCMPStatusNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSentinelConfigNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSplashdownTriggeredEventNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSplashdownAwardNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSplashdownAwardNotificationCustomWithMediaData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetRicochetTriggeredEventNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetRicochetAwardNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetRicochetAwardNotificationCustomWithMediaData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetJackpotAnnouncementNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetTriggerlessAnnouncementNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetExternalPaidNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetTriggerRejectedNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetSpeedMediaVersion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CardIn(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CardOut(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GamePlayedAfterCardIn(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__RequestNonCardedEvents(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetFlashStartAnnouncement(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetFlashUdpCompleteAnnouncement(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetFileInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetConfigEx(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetEventXMLFile(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__InEventTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__InTriggeredEventTrigger(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportEventMeterDeltas(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportGameStart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__AcknowledgeExternalPaid(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportSentinelInformation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportSentinelInformationWithOrientation(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportSentinelInformationEx(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ReportSentinelInformation25(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetThirdPartyBlob(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SendBlobToThirdParty(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetEventTriggerNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCasinoChallengeTriggeredEventNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCasinoChallangeIncrementNotification(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCasinoChallangeEventEndNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCasinoChallengeAwardNotificationCustom(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCasinoChallengeAwardNotificationCustomWithMediaData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCacheMethodList(struct soap*);

#endif

/* End of soapStub.h */
