#include "stdafx.h"
#include "PollerProtocol/PollerCheckMessage.h"

// Unit testing includes.
#include "gtest/gtest.h"

using namespace std;

	class PollerCheckMessage : public ::testing::Test
	{
	public:
		static const size_t MAC_ADDRESS_OFFSET = 6;

		static const BYTE m_playerCardInMessage[553];
		static const BYTE m_playerCardOutMessage[566];
		static const BYTE m_badCardReaderMessage[530];
		static const BYTE m_badTicketMessage[589];
	};

		/// <summary>
		/// Test CPollerCheckMessage constants:
		/// </summary>
		TEST_F(PollerCheckMessage, PollerCheckMessage_Constants)
		{
			// Test(s).
			ASSERT_EQ((DWORD)1, CPollerCheckMessage::MINIMUM_UNIQUE_ID) << L"MINIMUM_UNIQUE_ID";

			ASSERT_EQ((DWORD)52, CPollerCheckMessage::MINIMUM_METER_COUNT) << L"MINIMUM_METER_COUNT";
			ASSERT_EQ((DWORD)NUM_METERS, CPollerCheckMessage::MAXIMUM_METER_COUNT) << L"MAXIMUM_METER_COUNT";

			ASSERT_EQ((DWORD)1, CPollerCheckMessage::MINIMUM_METER_NUMBER) << L"MINIMUM_METER_NUMBER";
			ASSERT_EQ((DWORD)NUM_METERS, CPollerCheckMessage::MAXIMUM_METER_NUMBER) << L"MAXIMUM_METER_NUMBER";

			ASSERT_EQ((__int64)0, CPollerCheckMessage::MINIMUM_METER_VALUE) << L"MINIMUM_METER_VALUE";
			ASSERT_EQ((__int64)999999999999999999, CPollerCheckMessage::MAXIMUM_METER_VALUE) << L"MAXIMUM_METER_VALUE";

			ASSERT_EQ((__int64)1, CPollerCheckMessage::MINIMUM_COIN_IN_METER_VALUE) << L"MINIMUM_COIN_IN_METER_VALUE";
			ASSERT_EQ((__int64)1, CPollerCheckMessage::MINIMUM_COIN_OUT_METER_VALUE) << L"MINIMUM_COIN_OUT_METER_VALUE";

			static const BYTE macAddressNoInit[SIZE_OF_MAC_ADDRESS] = { 0, 0, 0, 0, 0, 0 };
			static const BYTE macAddressBroadcast[SIZE_OF_MAC_ADDRESS] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

			ASSERT_EQ(0,
				memcmp(macAddressNoInit, CPollerCheckMessage::m_macAddressNoInit, sizeof(macAddressNoInit))) <<
				L"m_invalidMacAddressNoInit";
			ASSERT_EQ(0,
				memcmp(macAddressBroadcast, CPollerCheckMessage::m_macAddressBroadcast, sizeof(macAddressBroadcast))) <<
				L"m_invalidMacAddressBroadcast";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a good player card in transaction.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_PlayerCardIn_Good)
		{
			// Data.
			const BYTE *msg(m_playerCardInMessage);
			WORD msgLength((WORD)sizeof(m_playerCardInMessage));
			const string reasonExpected;

			// Setup.
			BYTE macAddress[SIZE_OF_MAC_ADDRESS];
			memcpy(macAddress, msg + MAC_ADDRESS_OFFSET, SIZE_OF_MAC_ADDRESS);
			TiltCode tiltCode(tltUnknown);
			string reason;

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg, msgLength, macAddress, tiltCode, 0, reason);

			// Test(s).
			ASSERT_EQ(tltUnknown, tiltCode) << L"tiltCode";
			ASSERT_EQ(reasonExpected, reason) << L"reason";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a good player card out transaction.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_PlayerCardOut_Good)
		{
			// Data.
			const BYTE *msg(m_playerCardOutMessage);
			WORD msgLength((WORD)sizeof(m_playerCardOutMessage));
			const BYTE *macAddress(msg + MAC_ADDRESS_OFFSET);
			const string reasonExpected;

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg, msgLength, macAddress, tiltCode, 0, reason);

			// Test(s).
			ASSERT_EQ(tltUnknown, tiltCode) << L"tiltCode";
			ASSERT_EQ(reasonExpected, reason) << L"reason";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a bad player card out transaction, modified to match
		/// Defect 118472:1.51 Huge CashIn/CashOut. Bogus Meters. CardIn / CardOut Transaction.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_PlayerCardOut_Bad)
		{
			// Data.
			array<BYTE, sizeof(m_playerCardOutMessage)> msg;
			memcpy(msg.data(), m_playerCardOutMessage, msg.size());
			const BYTE *macAddress(msg.data() + MAC_ADDRESS_OFFSET);
			const string reasonExpected(_T("Invalid Meter: Number=25 (25-Credit Meter) Value=-4870209167306039233."));

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			const size_t cardNumberOffset = 2 * 16 + 15;
			const BYTE playerCardNumber[CARD_ID_LEN] = { 0x5d, 0x3a, 0x00, 0xcf, 0x1b };

			const size_t transactionTimeOffset = 1 * 16 + 7;
			const SYSTEMTIME playerCardOutTime = { 2014, 9, 1, 8, 6, 41, 30, 0 };

			// The meter numbers are in the BYTE that preceeds the value.
			const size_t creditValueOffset = 12 * 16 + 6;
			const __int64 cardOutCredit = -4870209167306039233;

			const size_t coinInValueOffset = 17 * 16 + 7;
			const __int64 cardOutCoinIn = -1;

			const size_t coinOutValueOffset = coinInValueOffset + 9;
			const __int64 cardOutCoinOut = -1;

			const size_t jackpotValueOffset = 20 * 16 + 13;
			const __int64 cardOutJackpot = -1;

			ASSERT_TRUE(2015 == *(const WORD *)(msg.data() + transactionTimeOffset)); // Verify the offset.
			memcpy(msg.data() + transactionTimeOffset, &playerCardOutTime, sizeof(playerCardOutTime));

			ASSERT_TRUE(0x4b == msg.data()[cardNumberOffset]); // Verify the offset.
			memcpy(msg.data() + cardNumberOffset, &playerCardNumber, sizeof(playerCardNumber));

			ASSERT_TRUE(mCrd == msg.data()[creditValueOffset - 1]); // Verify the offset.
			memcpy(msg.data() + creditValueOffset, &cardOutCredit, sizeof(cardOutCredit));

			ASSERT_TRUE(gCI == msg.data()[coinInValueOffset - 1]); // Verify the offset.
			memcpy(msg.data() + coinInValueOffset, &cardOutCoinIn, sizeof(cardOutCoinIn));

			ASSERT_TRUE(gCO == msg.data()[coinOutValueOffset - 1]); // Verify the offset.
			memcpy(msg.data() + coinOutValueOffset, &cardOutCoinOut, sizeof(cardOutCoinOut));

			ASSERT_TRUE(gJP == m_playerCardInMessage[jackpotValueOffset - 1]); // Verify the offset.
			memcpy(msg.data() + jackpotValueOffset, &cardOutJackpot, sizeof(cardOutJackpot));

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg.data(), msg.size(), macAddress, tiltCode, 0, reason);

			// Test(s).
			ASSERT_EQ(tltPollerProtocolCheckPacket, tiltCode) << L"tiltCode";
			ASSERT_EQ(reasonExpected, reason) << L"reason";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a good bad card reader transaction.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_BadCardReader_Good)
		{
			// Data.
			const BYTE *msg(m_badCardReaderMessage);
			WORD msgLength((WORD)sizeof(m_badCardReaderMessage));
			const BYTE *macAddress(msg + MAC_ADDRESS_OFFSET);
			const string reasonExpected;

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg, msgLength, macAddress, tiltCode, 0, reason);

			// Test(s).
			ASSERT_EQ(tltUnknown, tiltCode) << L"tiltCode";
			ASSERT_EQ(reasonExpected, reason) << L"reason";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a bad card reader transaction where the coin in meter is missing and poller is non-NFD.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_BadCardReader_CoinInMissing_NonNFD)
		{
			// Data.
			array<BYTE, sizeof(m_badCardReaderMessage)> msg;
			memcpy(msg.data(), m_badCardReaderMessage, msg.size());
			const BYTE *macAddress(msg.data() + MAC_ADDRESS_OFFSET);
			const string reasonExpected(_T("Meter Number 53 (53-Coin In) is missing from the transaction."));

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			// The meter numbers are in the BYTE that preceeds the value.
			const size_t coinInValueOffset = 17 * 16 + 7;
			ASSERT_TRUE(gCI == msg.data()[coinInValueOffset - 1]); // Verify the offset.
			msg.data()[coinInValueOffset - 1] = gCO; // Make the gCI meter missing for this transaction.

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg.data(), msg.size(), macAddress, tiltCode, 0, reason, false);

			// Test(s).
			ASSERT_EQ(tiltCode, tltPollerProtocolCheckPacket) << L"tiltCode";
			ASSERT_EQ(reason, reasonExpected) << L"reason";
		}

		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a card reader transaction where poller is NFD and coin in meter is  
		//  not supplied because it is 0 (we dont send meters with 0 values for NFD).
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_BadCardReader_CoinInMissing_NFD)
		{
			// Data.
			array<BYTE, sizeof(m_badCardReaderMessage)> msg;
			memcpy(msg.data(), m_badCardReaderMessage, msg.size());
			const BYTE *macAddress(msg.data() + MAC_ADDRESS_OFFSET);

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			// The meter numbers are in the BYTE that preceeds the value.
			const size_t coinInValueOffset = 17 * 16 + 7;
			ASSERT_TRUE(gCI == msg.data()[coinInValueOffset - 1]); // Verify the offset.
			msg.data()[coinInValueOffset - 1] = gCO; // Make the gCI meter missing for this transaction.

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg.data(), msg.size(), macAddress, tiltCode, 0, reason, true);

			// Test(s). We should consider this message as valid, so no tilt should be generated.
			ASSERT_EQ(tiltCode, tltUnknown) << L"tiltCode";
			ASSERT_EQ(reason, "") << L"reason";
		}
		
		/// <summary>
		/// Functional test and code coverage test for:
		///     CPollerCheckMessage::CheckMessage()
		/// Test with a corrupted ticket transaction.
		/// </summary>
		TEST_F(PollerCheckMessage, CheckMessage_BadTicket)
		{
			// Data.
			const BYTE *msg(m_badTicketMessage);
			WORD msgLength((WORD)sizeof(m_badTicketMessage));
			const BYTE *macAddress(msg + MAC_ADDRESS_OFFSET);
			const string reasonExpected(_T("Invalid Meter: Number=15 (15-Tens) Value=-2453300819995720232."));

			// Setup.
			TiltCode tiltCode(tltUnknown);
			string reason;

			// Perform operation(s) to be tested.
			CPollerCheckMessage::CheckMessage(msg, msgLength, macAddress, tiltCode, 0, reason);

			// Test(s).
			ASSERT_EQ(tltPollerProtocolCheckPacket, tiltCode) << L"tiltCode";
			ASSERT_EQ(reasonExpected, reason) << L"reason";
		}

	// One way to generate a test transaction is to get a dump of a similar transaction message and
	// then modify the transaction as desired.

	const BYTE PollerCheckMessage::m_playerCardInMessage[553] = {
	0x03, 0x00, 0x36, 0x01, 0x13, 0x02, 0x20, 0x6f, 0xec, 0x00, 0x08, 0x09, 0x93, 0x01, 0x00, 0x00,
	0xb1, 0x0b, 0x00, 0x00, 0x07, 0x00, 0x02, 0xdf, 0x07, 0x0a, 0x00, 0x05, 0x00, 0x09, 0x00, 0x13,
	0x00, 0x24, 0x00, 0x35, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x4b,
	0xcb, 0x04, 0xfd, 0x38, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1f, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x17, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x57, 0xd3, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x17, 0xa0, 0x23, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x28, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x4e, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x37, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36,
	0x13, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xa4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x84, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3a, 0xda, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xc7, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4f,
	0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x47, 0x70, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x68, 0x3a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x49, 0xd4, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x7b, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4b, 0x50, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e,
	0xe3, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xbc, 0x04, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0xc3, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x58, 0x04, 0xcc, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0xb2, 0xca,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x01, 0x00 };

const BYTE PollerCheckMessage::m_playerCardOutMessage[566] = {
	0x03, 0x00, 0x36, 0x01, 0x20, 0x02, 0x20, 0x6f, 0xec, 0x00, 0x08, 0x09, 0xca, 0x01, 0x00, 0x00,
	0xb1, 0x0b, 0x00, 0x00, 0x07, 0x00, 0x3c, 0xdf, 0x07, 0x0a, 0x00, 0x05, 0x00, 0x09, 0x00, 0x13,
	0x00, 0x25, 0x00, 0x13, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x4b,
	0xcb, 0x04, 0xfd, 0x38, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1f, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x17, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x57, 0xd3, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x17, 0xa0, 0x23, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x28, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x4e, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x3c, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36,
	0x13, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xa5, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x84, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3a, 0xda, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xc7, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4f,
	0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x47, 0x70, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x68, 0x3a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x49, 0xd4, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x7b, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4b, 0x50, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e,
	0xe3, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xbc, 0x04, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x18, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0xc3, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x58, 0x04, 0xcc, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x12, 0x00, 0x00, 0x00, 0x04, 0x08, 0xb2, 0xca,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x08, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x3c, 0x01, 0x00, 0x3d, 0x01, 0x00 };

const BYTE PollerCheckMessage::m_badCardReaderMessage[530] = {
	0x03, 0x00, 0x36, 0x01, 0xfc, 0x01, 0x20, 0x6f, 0xec, 0x00, 0x08, 0x09, 0x21, 0x02, 0x00, 0x00,
	0xb1, 0x0b, 0x00, 0x00, 0x07, 0x00, 0x46, 0xdf, 0x07, 0x0a, 0x00, 0x03, 0x00, 0x0e, 0x00, 0x0c,
	0x00, 0x07, 0x00, 0x31, 0x00, 0x00, 0x00, 0x77, 0x3e, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1f, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x17, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x57, 0xd3, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x17, 0xa0, 0x23, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x28, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x4e, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x46, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36,
	0x13, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xa7, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x84, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3a, 0xda, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4f, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x43, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x70, 0x21, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x48, 0x68, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0xd4, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x4a, 0x7b, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x50, 0x2a,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xe3, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x4f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x51, 0xbc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x18,
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x57, 0xc3, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x04, 0xcc, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00 };

// The following ticket transaction has corrupted data (starting with meter 0x0F) and occurred in the field.
// See the following emails for details.
// Sent: Friday, September 06, 2013 3:23 PM
// Sent: Thursday, October 03, 2013 1:09 PM
// Subject: FW:-1 NCEPPlayed meter and large coin in meter on ticket transaction
const BYTE PollerCheckMessage::m_badTicketMessage[589] = {
	0x03, 0x00, 0x36, 0x01, 0x37, 0x02, 0x20, 0x6F, 0xEC, 0x00, 0x11, 0xDF, 0xFD, 0x3D, 0x07, 0x00,
	0x3A, 0x31, 0x00, 0x00, 0x0D, 0x00, 0x6B, 0xDD, 0x07, 0x09, 0x00, 0x05, 0x00, 0x06, 0x00, 0x15,
	0x00, 0x2A, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x67, 0x3E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB2,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x8A, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xA8, 0x0D, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x92, 0x1A,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xD8, 0x05, 0xFB, 0x00, 0xE7, 0x1F, 0xF4, 0xDD, 0xA3, // Starting with meter 0x0F, the transaction data is corrupted.
	0xFC, 0x6B, 0x25, 0x9D, 0x0A, 0x88, 0x26, 0x50, 0x19, 0xAD, 0xA7, 0xB3, 0x4C, 0xD8, 0x8B, 0x49,
	0xDD, 0xB0, 0x8B, 0xF3, 0x2B, 0x63, 0x38, 0x28, 0x8B, 0x0C, 0xBC, 0x4E, 0xF6, 0x1D, 0x28, 0x88,
	0xBB, 0x5F, 0x7C, 0xEC, 0x6C, 0x20, 0x01, 0xF7, 0x42, 0x48, 0xA0, 0x2B, 0xE9, 0x06, 0xF4, 0xCD,
	0x4F, 0xB0, 0xCC, 0x55, 0xAD, 0x55, 0xDE, 0x28, 0xF0, 0xA8, 0x74, 0x00, 0x67, 0xE2, 0x45, 0xD7,
	0x2C, 0xE0, 0x4B, 0x83, 0x4A, 0x37, 0xCE, 0xAE, 0x15, 0x8E, 0xDB, 0x55, 0x8A, 0x9B, 0xCD, 0x80,
	0x18, 0xF5, 0x63, 0x75, 0x98, 0x0E, 0xD1, 0xDD, 0x4B, 0x6C, 0x26, 0x4C, 0xAD, 0xE3, 0x58, 0xBC,
	0x5A, 0xF8, 0x5D, 0x3E, 0xD5, 0xEB, 0xAC, 0xFC, 0xE8, 0x5D, 0xD5, 0xD8, 0x59, 0x74, 0x1F, 0xA8,
	0xA2, 0x9E, 0xFF, 0xFC, 0xD0, 0xD8, 0xD3, 0xB4, 0xB9, 0x35, 0x7C, 0x79, 0x7E, 0x35, 0x9A, 0x61,
	0x09, 0xCF, 0x66, 0xC0, 0x99, 0x39, 0xDB, 0x76, 0x49, 0x65, 0x5E, 0xA6, 0x85, 0xD7, 0x6C, 0xC9,
	0x66, 0xA7, 0xFD, 0xAC, 0xD7, 0xC4, 0x57, 0x54, 0x0F, 0xCF, 0x00, 0x36, 0xA8, 0xA6, 0x43, 0x1A,
	0x5C, 0x3B, 0xB5, 0x75, 0x15, 0xD7, 0x3B, 0x1E, 0x07, 0xB4, 0x92, 0x62, 0xBB, 0xC0, 0x03, 0xCF,
	0xDF, 0x96, 0xBA, 0xB0, 0x2D, 0x65, 0xBD, 0xC1, 0x0C, 0x3D, 0x6A, 0x35, 0xE4, 0x83, 0x7B, 0xA0,
	0xAC, 0x59, 0x95, 0xC3, 0x6F, 0xA3, 0xE6, 0xCE, 0xB6, 0x66, 0x7F, 0x0A, 0x1B, 0x75, 0x20, 0xB1,
	0x22, 0xBF, 0xFB, 0xA2, 0xBC, 0x1C, 0x2E, 0x53, 0x28, 0x8E, 0x3F, 0x20, 0x42, 0x59, 0xEF, 0xEB,
	0xE1, 0x56, 0xA8, 0x18, 0x48, 0x7D, 0x52, 0xF5, 0x63, 0x22, 0xE9, 0x34, 0x49, 0xB6, 0x7C, 0x82,
	0xA9, 0x46, 0xB7, 0xD7, 0x1A, 0xF5, 0xFA, 0xEE, 0xB8, 0x42, 0xBB, 0x04, 0xF8, 0x18, 0x31, 0x9D,
	0x0A, 0x95, 0x21, 0x68, 0xB6, 0x17, 0x18, 0x7D, 0xF9, 0x9D, 0xE0, 0xC0, 0xCB, 0x58, 0x1E, 0x98,
	0x65, 0xEB, 0xEA, 0xC1, 0x90, 0xF6, 0xC1, 0x31, 0x53, 0x11, 0x16, 0xF4, 0x93, 0x39, 0xBF, 0x75,
	0xB6, 0x0E, 0x15, 0xEC, 0x4D, 0x50, 0xA1, 0x8F, 0x89, 0x79, 0xDE, 0x29, 0x1C, 0x5D, 0x5E, 0x16,
	0xA5, 0x8F, 0x1C, 0x3E, 0xFA, 0xA9, 0x6F, 0x9D, 0xAE, 0x93, 0x33, 0x47, 0xC5, 0xD3, 0x29, 0x86,
	0x11, 0x5A, 0x89, 0x91, 0x73, 0xC0, 0x3E, 0x15, 0xDD, 0x63, 0xD5, 0x43, 0xFD, 0xB3, 0xC0, 0xB2,
	0x97, 0xA8, 0x9D, 0xAF, 0xB1, 0x2F, 0xF3, 0x18, 0x68, 0xA4, 0x34, 0xC9, 0xE8, 0x2C, 0x3A, 0x77,
	0x24, 0x03, 0xC7, 0xE9, 0x47, 0x78, 0x3A, 0x44, 0xF4, 0xF9, 0x03, 0xC0, 0x85, 0x4F, 0x6E, 0xFD,
	0xAC, 0xAA, 0x20, 0x35, 0x40, 0xE9, 0xF0, 0xCD, 0x46, 0x32, 0x48, 0x33, 0x8E, 0xC0, 0xF7, 0xBD,
	0x24, 0x23, 0x75, 0x67, 0x14, 0x58, 0x48, 0x84, 0x64, 0x2A, 0xEA, 0x70, 0x64, 0x9D, 0xC3, 0x50,
	0x31, 0xD4, 0x9B, 0x47, 0xF1, 0x14, 0x84, 0x8B, 0x14, 0x1D, 0x13, 0x91, 0x33, 0x44, 0x51, 0xBE,
	0x76, 0x98, 0xCB, 0xE6, 0x4F, 0x2E, 0x35, 0xE8, 0x67, 0x78, 0xD5, 0xBF, 0x81, 0x6E, 0x5C, 0x3B,
	0x6E, 0xCB, 0x9E, 0x35, 0xC7, 0xA9, 0xB7, 0x4B, 0x2C, 0xF9, 0x3F, 0x8C, 0x7C };
